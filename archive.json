{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-11-14T00:54:56.065696+00:00",
  "repo": "quicwg/ack-frequency",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "bfd4f2"
    },
    {
      "name": "design",
      "description": "",
      "color": "B60205"
    },
    {
      "name": "needs-pr",
      "description": "",
      "color": "1D76DB"
    },
    {
      "name": "needs-discussion",
      "description": "",
      "color": "5319E7"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU1NDc2NjUzMDY=",
      "title": "Discuss whether this affects the max_ack_delay used in PTO",
      "url": "https://github.com/quicwg/ack-frequency/issues/1",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If it doesn't change it, we should say so.  If it allows it to be reduced, then we need to understand what the limits are(ie: it can't be lowered to 1us presumably?).\r\n\r\nAdmittedly, the way we're using max_ack_delay should be safe to assuming a 0 value, since the SRTT will accrue the excess.",
      "createdAt": "2020-01-09T19:09:49Z",
      "updatedAt": "2020-01-17T21:59:36Z",
      "closedAt": "2020-01-17T21:59:36Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU1NDc2NjY5MDE=",
      "title": "Make both parameters required and specify invalid values",
      "url": "https://github.com/quicwg/ack-frequency/issues/2",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think it'll be easier to make both parameters required.  Not doing so saves 1 to 2 bytes, which is really not much in a frame I expect will be sent a few times a connection.\r\n\r\nAlso, I think 0 should be an invalid value for both params, and 1 should be invalid for the number of packets, though I can see someone arguing that point.",
      "createdAt": "2020-01-09T19:12:32Z",
      "updatedAt": "2020-01-17T20:29:05Z",
      "closedAt": "2020-01-17T20:29:05Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "#4 addresses these issues, with the exception that 1 is allowed for packet tolerance. I think that's actually useful for some startup schemes, so we shouldn't disallow it.",
          "createdAt": "2020-01-17T20:28:04Z",
          "updatedAt": "2020-01-17T20:28:04Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1NDc2Njg2MTE=",
      "title": "Make both fields in the frame required",
      "url": "https://github.com/quicwg/ack-frequency/issues/3",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think it'll be easier to make both parameters required.  Not doing so saves 1 to 2 bytes, which is really not much in a frame I expect will be sent a few times a connection.  It also means the frame only needs one type value.\r\n\r\nAlso, I think 0 should be an invalid value for both params, and 1 should be invalid for the number of packets, though I can see someone arguing that point.",
      "createdAt": "2020-01-09T19:16:10Z",
      "updatedAt": "2020-01-09T19:16:29Z",
      "closedAt": "2020-01-09T19:16:29Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU1NTE2NDA4MTc=",
      "title": "Frame should have its own sequence number",
      "url": "https://github.com/quicwg/ack-frequency/issues/5",
      "state": "CLOSED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently use PNs for ordering, but that runs afoul of requirements at the receiver specified in [https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-13.3-5](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-13.3-5).",
      "createdAt": "2020-01-17T21:30:10Z",
      "updatedAt": "2020-01-17T22:47:58Z",
      "closedAt": "2020-01-17T22:47:58Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU1NTE2NDE3MTQ=",
      "title": "Allow reordering-tolerant ack delay",
      "url": "https://github.com/quicwg/ack-frequency/issues/6",
      "state": "CLOSED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Endpoints expect the connection to encounter reordering might want to indicate that the receiver should not send immediate acks on receiving a reordered packet.",
      "createdAt": "2020-01-17T21:32:42Z",
      "updatedAt": "2020-01-18T00:01:17Z",
      "closedAt": "2020-01-18T00:01:17Z",
      "comments": []
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU1NTMwNTc1NDQ=",
      "title": "Slow Start and Hystart need references",
      "url": "https://github.com/quicwg/ack-frequency/issues/14",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\"Starting a connection up quickly without inducing much queue is important for latency reduction, for both short and long flows. The sender often needs frequent acknowledgments during this phase; see slow start and hystart.\"\r\n\r\nThere's no description of them in this doc.  Slow start is in the recovery draft, but hystart is not, so we'd have to reference a non-QUIC RFC?",
      "createdAt": "2020-01-21T18:40:01Z",
      "updatedAt": "2020-01-31T02:50:22Z",
      "closedAt": "2020-01-31T02:50:22Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe paced chirping too.",
          "createdAt": "2020-01-21T23:47:20Z",
          "updatedAt": "2020-01-21T23:47:20Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An added nit to this: congestion controllers like BBR do not have a slow start / hystart phase exactly, but are still sensitive to ACKs early in the flow during \"Startup\". With a BBR congestion controller the ACKing interval early in the flow has a measurable effect on the time it takes to find the bottleneck bandwidth.\r\n\r\nMore generally I suspect this is true of pretty much every congestion controller that's trying to find an optimal congestion window. Given that, perhaps we need more general language here about the benefit of ACKs early in a flow, and then referencing slow start and hystart specifically?",
          "createdAt": "2020-01-23T22:48:31Z",
          "updatedAt": "2020-01-23T22:48:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "BBR has 'Startup', which is quite similar to slow start, so maybe flow startup a better general purpose term?\r\n\r\nI think we can remove the reference to hystart entirely, since I wouldn't expect decreasing ACK frequency to have a negative impact on it, particularly given QUIC's explicit ack delay.",
          "createdAt": "2020-01-23T23:13:48Z",
          "updatedAt": "2020-01-23T23:13:48Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU1NTQ0NDE1ODY=",
      "title": "Should this extension recommend an endpoint behavior?",
      "url": "https://github.com/quicwg/ack-frequency/issues/17",
      "state": "CLOSED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on [3304](https://github.com/quicwg/base-drafts/issues/3304) in the base draft, we have some confidence in a particular heuristic (default tolerance of 2 for the first 100 packets, followed by a tolerance of 10) which we know to work fairly well in multiple deployments serving \"typical\" Internet resources to typical users. Do we want to make that recommendation explicit, or otherwise give guidance in this extension?",
      "createdAt": "2020-01-23T22:22:04Z",
      "updatedAt": "2020-03-19T23:08:56Z",
      "closedAt": "2020-03-19T23:08:56Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's a good idea to describe the values for which we have experience, while encouraging experimentation. We don't need to _recommend_ the strategy, we just need to document it as an example strategy.",
          "createdAt": "2020-01-23T22:29:52Z",
          "updatedAt": "2020-01-23T22:29:52Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a section on considerations and maybe past experience would be very helpful.  I think it's going to be a bit of a challenge to write, but I'm happy to take a stab if no one else wants to.",
          "createdAt": "2020-01-25T00:02:21Z",
          "updatedAt": "2020-01-25T00:02:21Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "What I'd want to see is just a simple explanation of what a sender could do... I would not describe results from experience, since those are anecdotal and are going to change over time. This could be a fairly short section.",
          "createdAt": "2020-01-25T00:36:44Z",
          "updatedAt": "2020-01-25T00:36:44Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@janaiyengar @ianswett I can take a stab at writing something and we can go from there.",
          "createdAt": "2020-01-28T00:26:07Z",
          "updatedAt": "2020-01-28T00:26:07Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @mjoras !",
          "createdAt": "2020-01-28T00:29:15Z",
          "updatedAt": "2020-01-28T00:29:15Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do think the pitfalls of e.g. #25 should be conveyed in such \"cautionary\" text as well. I will submit a PR this week time permitting between interop.",
          "createdAt": "2020-02-03T07:11:00Z",
          "updatedAt": "2020-02-03T07:11:00Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU1NTQ1MjI3MzI=",
      "title": "Why is the response to reordering a TP?",
      "url": "https://github.com/quicwg/ack-frequency/issues/18",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Maybe it would be more consistent if this was a field on the ACK_FREQUENCY frame?",
      "createdAt": "2020-01-24T03:12:58Z",
      "updatedAt": "2020-02-03T16:23:11Z",
      "closedAt": "2020-02-03T16:23:11Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "I agree. Not only for consistency but also for practical benefits.\r\n\r\nFirstly, in many cases, the sender will only be able to tell if the path is going to have lots of reorders. Allowing the sender to alter the client behavior mid-connection would be beneficial, as that would allow the sender reduce the ACK rate when it disables packet number-based loss detection.\r\n\r\nThe second use case is for clustered servers sending different streams from different hosts. Packets being sent from such clustered servers would have reorder when there are multiple servers handling streams, but not when there is only server handling streams (consider the case where only one stream, or only one HTTP request is open). In such deployments, it is beneficial to have the capability of turning off reordering detection mid-connection.",
          "createdAt": "2020-01-24T06:30:24Z",
          "updatedAt": "2020-01-24T06:30:24Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Firstly, in many cases, the sender will only be able to tell if the path is going to have lots of reorders. Allowing the sender to alter the client behavior mid-connection would be beneficial, as that would allow the sender reduce the ACK rate when it disables packet number-based loss detection.\r\n\r\nLet's assume here that peers might adjust their reordering threshold based on the amount of reordering they're seeing, i.e. that they will increase it from the default value of 3 to a higher value if they detect a lot of spurious retransmissions when using 3.\r\nIn that case, would it maybe make sense to define a threshold when to send an ACK for a reordered packet? For example, let's say packet N is missing, but N+1 is received. If you're using a high reordering threshold, you wouldn't care to receive an ACK for this event immediately. However, you'd still care to get an ACK when N+10 is received, because in that case your packet number-based loss detection will be able to quickly repair the loss of packet N.\r\n",
          "createdAt": "2020-01-24T06:40:51Z",
          "updatedAt": "2020-01-24T06:40:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@marten-seemann I agree that that's a possibility. At the same time, it could be well the case that simply turning off reordering detection and solely relying on the time-based loss recovery would be sufficient.",
          "createdAt": "2020-01-24T07:06:41Z",
          "updatedAt": "2020-01-24T07:06:41Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I can't really tell what makes sense from the point of a congestion control algorithm, but I'm wondering if it makes sense to specify something here that would allow a wide range of algorithms to get the kind of information that they deem useful.\r\nIf we made that field a varint instead of a bool (then we can also avoid the question of how we would encode a bool), you could still effectively disable ACKs for reordered packets by sending a very large value for that field, if you want to disable packet number-based loss recovery.",
          "createdAt": "2020-01-24T07:25:31Z",
          "updatedAt": "2020-01-24T07:25:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "When @janaiyengar and I were discussing this, we thought it was best to not make this part of the mechanism overly complex, hence the transport param.  Unfortunately, we have very little(or no) deployment experience in this area, so the TP was more of a future-proofing mechanism than one based on past experience.\r\n\r\nIf we were going to add a field, I'd suggest a max_reordering field where 0 indicates any reordering is tolerated and any other values indicate a max packet number gap before an immediate ACK is sent?  If you want immediate ACK upon reordering, you'd send 1.\r\n\r\nThat only adds a byte to the frame size in almost all cases, but I think should work well in a wide variety of use cases.  \r\n\r\nMy main concern is whether the implementation complexity increases more than the value it's providing?\r\n\r\n",
          "createdAt": "2020-01-24T23:57:29Z",
          "updatedAt": "2020-01-24T23:57:29Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there's value in making this a field in the frame instead of a TP... as @ianswett noted, we used a TP because that seemed like the simplest approach, not necessarily the most flexible one.\r\n\r\nI agree with @marten-seemann that allowing for communicating a \"threshold\" has the most room for play with reordering robustness in the future. I'm not convinced that it'll get all that used, but if the receiver behavior is not much more complicated to implement, then I'm ok with specifying that.\r\n\r\nSo, here's a shot at defining receiver behavior. A receiver has to measure the degree of reordering and then decide whether to ack immediately or not.  This degree of reordering can be defined as follows: the distance of the received packet from the largest_received (for that PN space). Basically:\r\n\r\n```\r\nif (PN > LR):\r\n    if (PN - LR >= max_reordering): send immediate ack\r\nelse:\r\n    if (LR - PN >= max_reordering): send immediate ack\r\n```\r\n\r\nA couple of examples to see if this works out. Let's say LR is the largest_received packet number.\r\n\r\nA reordering distance of 2 means that LR+2 and larger or LR-2 and smaller will trigger an immediate ack. This seems ok. All distances greater than 2 also seem ok.\r\n\r\nReordering distance of 1 is a bit tricky. This distance means that if LR+1 is received, that triggers an immediate ack. Similarly, anything smaller than or equal to LR-1 will also trigger immediate ack (anything smaller than the largest received). The current reordering recommendation in the transport draft will have the receiver acking immediately on receiving LR-1, and we should be able to cover that case, so we should be able to express this value.\r\n\r\nBut this is a bit wonky, since LR+1 is basically the next expected, and this reordering value effectively turns into `ack every packet`. It would be nice to avoid this problem. We can do that by using Ian's suggestion of special casing the value 1: \"any reordering, as defined as a PN that does not increase the LR by 1, will trigger an ack.\"\r\n\r\nSimilarly, special casing the value 0 for disable immediate acking on reordering is useful.\r\n\r\nHaving worked through this, it doesn't seem that terrible. I'm ok with varint or single byte. I agree with @ianswett that the most usefulness will be in 1 byte, but I can see the value in leaving it open and uniform.\r\n\r\nThoughts?",
          "createdAt": "2020-01-25T01:17:00Z",
          "updatedAt": "2020-01-25T01:17:00Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "So the final algorithm becomes:\r\n```\r\nbool ShouldSendImmediateAck(uint LR, uint PN):\r\n    if (max_reordering == 0): return false\r\n    if (max_reordering == 1):\r\n        if (PN != LR+1): return true\r\n        else: return false\r\n\r\n    if (PN > LR):\r\n        if (PN - LR >= max_reordering): return true\r\n    else:\r\n        if (LR - PN >= max_reordering): return true\r\n\r\n    return false\r\n```",
          "createdAt": "2020-01-25T01:21:48Z",
          "updatedAt": "2020-01-25T01:21:48Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd rather have a varint for consistency, even if it's almost always a single byte.",
          "createdAt": "2020-01-25T01:38:46Z",
          "updatedAt": "2020-01-25T01:38:46Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@janaiyengar, thank you for picking up my suggestion and writing the pseudo code.\r\nI'm not sure if just looking at the largest received is sufficient to properly cover all cases. Assume you receive packet `N`, packet `N+2`. At this point `LR = N+2`. Now you receive `N + max_reordering`. I would have assumed that it makes sense now to send an immediate ACK to help with the recovery of `N+1`, however, the algorithm doesn't capture that case.\r\n\r\nFurthermore, I was wondering about the negative branch (where `PN < LR`). This branch can only be taken if we sent an ACK earlier for exceeding the `max_reordering`. Assuming that ACK was received, the packet in question would already have been declared lost, so in that case sending an immediate ACK wouldn't make any difference. Is my understanding correct that the negative branch exists for the case in which the original ACK was lost?\r\n\r\nEncoding-wise, we might be able to simplify things a bit replacing `max_reordering` by `max_gap` (where a `max_gap` of 1 would be a `max_reordering` of 2). Then we could avoid special-casing the value of 1.\r\n\r\nI'm also wondering how many immediate ACKs you're supposed to send. Currently, the draft has some quite complicated conditions for this:\r\n> an endpoint SHOULD send an ACK frame immediately on receiving an ack-eliciting packet that is out of order. The endpoint MAY continue sending ACK frames immediately on each subsequently received packet, but the endpoint SHOULD return to acknowledging every other packet within a period of 1/8 x RTT, unless more ack-eliciting packets are received out of order.\r\n\r\nDo we need some similar advice here? Or do we need to make it configurable?\r\n",
          "createdAt": "2020-01-25T05:42:51Z",
          "updatedAt": "2020-01-25T05:42:51Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann on the point about how many immediate ACKs to send, I believe we should only send one, so I have an issue(#3357) and PR(#3361) to change the text you quoted.\r\n\r\nIn terms of the 'negative branch' as you're describing it, the idea is that it's very possible the packet has not yet been declared lost yet, even though the ACK has arrived.  If they're using this reordering tolerant setting, it seems likely they're tolerant to more reordering than a typical sender.  For example, it could be because they have adaptive packet threshold loss detection and the threshold has been increased substantially due to observing past reordering.",
          "createdAt": "2020-01-25T15:48:36Z",
          "updatedAt": "2020-01-25T15:48:36Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We definitely need to have a few people ship this reordering tolerant feature before we finalize this draft.  I'm quite confident in everything else in the draft, but I'm fairly unsure about exactly how this can and should be used.  I'm also not yet sure packet threshold is actually better than time.  It seems more appealing, but I think it depends on the use case.\r\n\r\nI'm also concerned it adds non-trivial implementation complexity.  Implementations already have a max_ack_delay and a number of packets before sending an immediate ACK, so this is just adding a mechanism to change those thresholds during the connection.  However, this reordering feature may end up substantially changing the code to send ACKs.  I'd be pretty sad if a bunch of implementations didn't implement the draft because they didn't want to deal with the extra complexity.",
          "createdAt": "2020-01-25T21:30:39Z",
          "updatedAt": "2020-01-25T21:30:39Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, @ianswett, which is why I wanted to go through and see if we could define simple enough behavior that is useful.\r\n\r\nI don't think we want to be perfect with the detection, but reasonable. I'll think of simplifications to this, but we want to make sure that we dont make this unnecessarily ornate. I am concerned that this threshold becomes another footgun, since we really don't have a good recommendation for how to set it.\r\n\r\nThe primary property we want is a dynamic way to indicate to the peer to not send immediate acks on reordering. Simply moving the TP to the frame will give us that.\r\n\r\nI am increasingly leaning towards just calling this a boolean instead of a threshold. I will plan to write that up by tomorrow. Any strong objections?",
          "createdAt": "2020-02-01T22:28:05Z",
          "updatedAt": "2020-02-01T22:28:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Boolean as a frame field works perfectly fine for my use case.",
          "createdAt": "2020-02-02T02:34:01Z",
          "updatedAt": "2020-02-02T02:34:01Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU1NTcxMDk4MzQ=",
      "title": "Use underscore in frame name",
      "url": "https://github.com/quicwg/ack-frequency/issues/19",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [
        "ianswett"
      ],
      "labels": [],
      "body": "Use `ACK_FREQUENCY` instead of `ACK-FREQUENCY` following naming convention in the transport draft.",
      "createdAt": "2020-01-29T20:54:47Z",
      "updatedAt": "2020-01-31T02:49:44Z",
      "closedAt": "2020-01-31T02:49:44Z",
      "comments": []
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU1NTcxMTc3OTE=",
      "title": "min/max delay clarification",
      "url": "https://github.com/quicwg/ack-frequency/issues/20",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've re-read the draft a few times, but I still want to ask you to verify my understanding, just to be sure:\r\n\r\n1. Each side informs the other of **its own** minimum and maximum ACK delay values using the (new) `min_ack_delay` and `max_ack_delay` transport parameters.\r\n\r\n2. The `Update Max Ack Delay` value changes the **peer's** maximum ACK delay.  It must not be smaller than the `min_ack_delay` advertised by the peer.",
      "createdAt": "2020-01-29T21:11:17Z",
      "updatedAt": "2020-02-27T23:40:06Z",
      "closedAt": "2020-02-27T23:40:06Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@dtikhonov : Yes, that is correct. I know it can be a bit confusing. Hope the text is clear on this though.",
          "createdAt": "2020-01-30T21:09:45Z",
          "updatedAt": "2020-01-30T21:09:45Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@dtikhonov : I'm closing this issue. If you think we ought to clarify this in the text further, please re-open.",
          "createdAt": "2020-02-27T23:40:06Z",
          "updatedAt": "2020-02-27T23:40:06Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU1NTcxMzQ4MDM=",
      "title": "Specify in which packets ACK_FREQUENCY may appear",
      "url": "https://github.com/quicwg/ack-frequency/issues/22",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "See Table in [Section 12.4](https://tools.ietf.org/html/draft-ietf-quic-transport-25#section-12.4) of the transport draft.",
      "createdAt": "2020-01-29T21:46:27Z",
      "updatedAt": "2021-09-10T16:15:48Z",
      "closedAt": "2021-09-10T16:15:48Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "We recommend endpoints to ACK Initial and Handshake packets immediately (see https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-13.2.1-1). I do not think we need to change that, and therefore my view is that use of ACK_FREQUENCY frames can (and should) be limited to 1-RTT.",
          "createdAt": "2020-01-30T00:06:06Z",
          "updatedAt": "2020-01-30T00:10:37Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, I think we just need to specify that.",
          "createdAt": "2020-01-30T00:26:07Z",
          "updatedAt": "2020-01-30T00:26:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Just a note that, new TPs are required to clarify if the TP is to be remembered (https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-7.4.1-3).\r\n\r\nBased on the understanding that the use of the ACK_FREQUENCY frame will be limited to 1-RTT packets, I assume that remembering the min_ack_delay TP will be prohibited.",
          "createdAt": "2020-10-22T05:23:59Z",
          "updatedAt": "2020-10-22T05:23:59Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point @kazuho I do not believe min_ack_delay should be remembered, since it has no use prior to handshake completion.",
          "createdAt": "2020-10-22T06:38:07Z",
          "updatedAt": "2020-10-22T06:38:07Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We recommend endpoints to ACK Initial and Handshake packets immediately\r\n\r\n> Based on the understanding that the use of the ACK_FREQUENCY frame will be limited to 1-RTT packets\r\n\r\nI agree that ACK_FREQUENCY should not apply to Initial and Handshake packets. That doesn't mean that we need to limit ACK_FREQUENCY to 1-RTT packets though, it could apply to 0-RTT packets as well, if peers are required to remember the value of the TP. The client could then send an ACK_FREQUENCY in 0-RTT.\r\n\r\nI don't have a strong preference in either direction, but preventing a flood of ACKs for 0-RTT packets sounds like it could potentially be useful.",
          "createdAt": "2021-01-11T07:18:59Z",
          "updatedAt": "2021-01-11T07:18:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Considering our track record of allowing most frames to be sent in 0-RTT, I am fine with allowing the transmission of ACK_FREQUENCY frames in 0-RTT.\r\n\r\nOTOH, I do not think we should require endpoints to retain min_ack_delay TP across resumptions. That would essentially prohibits client from sending ACK_FREQUENCY frames in 0-RTT.",
          "createdAt": "2021-01-11T07:29:45Z",
          "updatedAt": "2021-01-11T07:29:45Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho Your two statements seem to contradict each other. If we allow ACK_FREQUENCY in 0-RTT, peers need to remember the value of the TP. If peers are not required to remember the value of the TP, ACK_FREQUENCY can't be sent in 0-RTT, otherwise a client would risk a PROTOCOL_VIOLATION if a server disabled the extension.",
          "createdAt": "2021-01-11T07:34:56Z",
          "updatedAt": "2021-01-11T07:34:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@marten-seemann That's a good point. And as you might have already observed, even if the client remembered min_ack_delay, it might still not be possible to send an ACK_FREQUENCY frame in 0-RTT. That's because max_ack_delay would be unknown.\r\n\r\nI think we are reaching consensus that clients would not send ACK_FREQUENCY frames in 0-RTT, even if the specification allowed that?",
          "createdAt": "2021-01-11T11:33:49Z",
          "updatedAt": "2021-01-11T11:33:49Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @marten-seemann That's a good point. And as you might have already observed, even if the client remembered min_ack_delay, it might still not be possible to send an ACK_FREQUENCY frame in 0-RTT. That's because max_ack_delay would be unknown.\r\n\r\nNow I'm a bit confused. In my mind, this is how this extension works (describing it using \"client\" and \"server\" for added clarity, it works the same way in the opposite direction):\r\nThe client declares a max_ack_delay in the transport parameters. When generating acknowledgements, the server will then make sure that every ACK is generated within that time frame. When the client sends an ACK_FREQUENCY frame, it instructs the server to discard the previous max_ack_delay value and use the one encoded in the frame instead.\r\n\r\nAssuming that my understanding is correct, the fact that the client hasn't received the server's max_ack_delay should be irrelevant when considering whether we want to send this frame in 0-RTT packets. Furthermore, the fact that the ClientHello has to be received before the server can decode any 0-RTT packet would guarantee that the server has processed the client's transport parameters before it is able to process any ACK_FREQUENCY frame.",
          "createdAt": "2021-01-11T11:47:01Z",
          "updatedAt": "2021-01-11T11:47:01Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett and I chatted about this; summarizing. An endpoint's ACK_FREQUENCY_FRAME updates the received max_ack_delay. This makes all situations where an endpoint sends an ACK_FREQUENCY_FRAME without receiving the peer's max_ack_delay problematic. Since a client does not remember the peer's max_ack_delay, sending an ACK_FREQUENCY_FRAME that updates it makes little sense.\r\n\r\nWe should disallow ACK_FREQUENCY_FRAMEs in 0-RTT packets because a client does not have the base value which it wants to update with this frame until 1-RTT keys are established.",
          "createdAt": "2021-07-12T17:37:37Z",
          "updatedAt": "2021-07-12T17:37:37Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "And we agree with @kazuho that #40 is intertwined with this issue, since if the transport parameter is not remembered, you can't send the ACK_FREQUENCY frame.",
          "createdAt": "2021-07-12T17:49:00Z",
          "updatedAt": "2021-07-12T17:49:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "My preference here is \"application\" packet number space.\r\n\r\nThis means that the transport parameter needs to be remembered.  It also means that - because max_ack_delay is not remembered - that you have to avoid exceeding the max_ack_delay default (and permit that variance as a server if you set a lower value for max_ack_delay).",
          "createdAt": "2021-07-27T21:01:20Z",
          "updatedAt": "2021-07-27T21:02:05Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "My real issue is whether the frames might appear before the TP negotiation has concluded. The client should not send ACK FREQUENCY frames before that. I think this naturally precludes sending ACK FREQUENCY in 0-RTT, but there might be corner cases in which the client knows the result of the TP negotiation before it has access to the 1-RTT keys -- for example if some of the crypto processing is going on in a crypto offload engine. If we are firm on negotiation, then we don't need to make a statement about 0RTT vs 1RTT.",
          "createdAt": "2021-07-27T21:10:11Z",
          "updatedAt": "2021-07-27T21:10:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@huitema I'm not sure if that follows the design of RFC 9000.\r\n\r\nFor frames that can be sent in 0-RTT, RFC 9000 requires endpoints to remember and reuse the value of the Transport Parameters:\r\n> When sending frames in 0-RTT packets, a client MUST only use remembered transport parameters; importantly, it MUST NOT use updated values that it learns from the server's updated transport parameters or from frames received in 1-RTT packets. ([section 7.4.1 of RFC 9000](https://quicwg.org/base-drafts/rfc9000.html#section-7.4.1-12))",
          "createdAt": "2021-07-28T06:52:35Z",
          "updatedAt": "2021-07-28T06:52:35Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Another potential option here in support of the basic design: this document could require that the value of max_ack_delay be remembered alongside min_ack_delay, (only)? for the generation of ACK_FREQUENCY frames.",
          "createdAt": "2021-07-28T07:03:11Z",
          "updatedAt": "2021-07-28T07:03:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson Would you mind elaborate why your implementation cannot prohibit frames being sent in 0-RTT packets from being affected by TPs other than remembered ones?\r\n\r\nRFC 9000 states that _when sending frames in 0-RTT packets, a client MUST only use remembered transport parameters_, and that _the definition of a new transport parameter MUST specify whether storing the transport parameter for 0-RTT is mandatory, optional, or prohibited_ ([section 7.4.1](https://quicwg.org/base-drafts/rfc9000.html#section-7.4.1)).\r\n\r\nSo it seems to me that, for Transport parameters that are prohibited to be remembered, QUIC stacks are expected to be capable of prohibiting those parameters to be used when sending frames using 0-RTT packets.\r\n\r\nIt seems to me that you are against us building extensions on that guidance.",
          "createdAt": "2021-07-28T07:13:34Z",
          "updatedAt": "2021-07-28T07:13:34Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I think there is broad support for not sending ACK_FREQUENCY frames before the negotiation completes. In response to the comment from @kazuho, this requires that \"storing the transport parameter for 0-RTT is prohibited.\" If we do that, we also satisfy the requirement stated by @martinthomson that 0-RTT processing be pretty much the same as 1-RTT processing: there is no new difference between 0-RTT and 1-RTT, in both cases the transport can only send the frame if the peer has explicitly accepted them.",
          "createdAt": "2021-07-28T17:18:46Z",
          "updatedAt": "2021-07-28T17:18:46Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @kazuho and @huitema I agree that if we prohibit storing min_ack_delay, ACK_FREQUENCY can't be sent in 0-RTT, and I believe that should solve @martinthomson issue?\r\n\r\nStoring BOTH min_ack_delay and max_ack_delay is a direction I'd really rather avoid.  ",
          "createdAt": "2021-07-28T20:16:20Z",
          "updatedAt": "2021-07-28T20:16:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This works to ensure that there are no surprises for servers. But it doesn't prevent clients from sending the frame in 0-RTT. Our stack will apply transport parameters after receiving them. This is before handshake completion, so if we are still sending 0-RTT, we might send the frame. I don't believe that we will in practice, due to the logic we use for sending it. That logic is something that might change, so there are no strong guarantees.\r\n\r\nI do think that this is a good solution, I just want to make the consequences clear.",
          "createdAt": "2021-07-31T23:48:43Z",
          "updatedAt": "2021-07-31T23:48:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson If we are to prohibit min_ack_delay from being remembered, I do not think we can allow them to be sent in 0-RTT. \r\n\r\nRequoting from RFC 9000, _when sending frames in 0-RTT packets, a client MUST only use remembered transport parameters_, and that _the definition of a new transport parameter MUST specify whether storing the transport parameter for 0-RTT is mandatory, optional, or prohibited_ ([section 7.4.1](https://quicwg.org/base-drafts/rfc9000.html#section-7.4.1)).\r\n\r\nAm I missing something?\r\n\r\nAlso, I would point out that, even for remembered TPs, QUIC stacks are required to refrain from using the newly received ones in 0-RTT packets. For example, if the remembered value of MAX_STREAMS is 0 and the newly received value is 4, an endpoint is forbidden to open _any_ stream in 0-RTT even _after_ receiving the transport parameters. It is only when you switch to using 1-RTT packets that the newly received transport parameter is applied.\r\n\r\nFor your implementation, wouldn't it be possible to use the same latch for ack_frequency?",
          "createdAt": "2021-08-01T22:08:04Z",
          "updatedAt": "2021-08-01T22:08:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Oh, whoops.  We don't have that latch.  We'll probably open 4 streams if initial_max_streams_xxx is 4 in the handshake and we remembered 0.\r\n\r\nIn any case, we can probably add a latch.  It might even make the code simpler.",
          "createdAt": "2021-08-02T05:18:55Z",
          "updatedAt": "2021-08-02T05:18:55Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU1NTg3Njk1NDE=",
      "title": "what between false start and handshake done?",
      "url": "https://github.com/quicwg/ack-frequency/issues/25",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "needs-pr"
      ],
      "body": "I found an interesting regression when implementing the delayed ack extension. The extension allows the sender of the data to control the max ack delay and the ack gap. In general that's a good idea, but not for the 2 RTT of the connection. Once the client obtains the 1RTT key, it will start receiving data sent by the server in \"false start\". At that point the client has assessed the RTT of the connection, but the server has not. The \"max ack delay\" sent by the server is a guess based on statistics. It will typically be longer than recommended values like RTT/4. The effect is that the first ACKs are sent too late, which  has a cascading effect with some congestion control algorithms.\r\n\r\nMy fix was to use the values locally computed by the client until the session is confirmed and the server can send accurate \"ack frequency\" frames. Not sure whether we should have text about that in the draft.",
      "createdAt": "2020-02-02T22:36:49Z",
      "updatedAt": "2021-09-10T16:23:50Z",
      "closedAt": "2021-09-10T16:23:50Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not completely clear on the details here, so hopefully you can clarify.\r\n\r\nIs the server sending an ACK_FREQUENCY frame in 0.5RTT before it has any RTT samples?  If so, yes I would say that's a bad idea and we should add a SHOULD NOT to advise against that.  And the regression is that slow start is slowed down substantially vs the default behavior of sending an ACK every 2 packets?  Or is there another regression?\r\n\r\nPossibly this issue is a variation on #17 about recommendations and potential pitfalls of this extension frame?",
          "createdAt": "2020-02-03T00:28:26Z",
          "updatedAt": "2020-02-03T00:28:26Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "At 0.5 RTT, the server will start sending data frames: HTTP settings for example, or maybe responses to client requests in 0-RTT packets. \r\n\r\nAs you say, the server should not send an ACK FREQUENCY frame in 0.5RTT before it has any RTT samples. Let's assume it doesn't.\r\n\r\nThe client knows that Min Ack Delay has been negotiated. In that case, my first implementation of the extension was completely deferring to the server, and just setting Ack Delay Max to the parameter advertised by the server. After all, the draft does says that the ACK FREQUENCY frame carries _an update to the peer's \"max_ack_delay\" transport parameter_. That was be by the book. But it was also causing regressions in a number of performance tests, because the value in the TP is typically an upper bound. The acks were sent too late, the connection was ramping up too slowly.",
          "createdAt": "2020-02-03T00:57:48Z",
          "updatedAt": "2020-02-03T00:57:48Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, presumably the client is setting \"Packet Tolerance\" to a value larger than 2 in its ACK_FREQUENCY frame?  If so, that makes sense.\r\n\r\nIn the \"Motivations\" section, the existing draft says:\r\n\"Starting a connection up quickly without inducing excess queue is important for latency \r\n reduction, for both short and long flows. The sender often needs more frequent \r\n acknowledgments during this phase.\"\r\n\r\nBut maybe there needs to be more cautionary text later in the draft, and less text in \"Motivations\"?",
          "createdAt": "2020-02-03T01:27:17Z",
          "updatedAt": "2020-02-03T01:27:17Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing editors' discussion: the issue here seems to be that in an interpretation of the mechanism, the client could change its behavior after receiving `min_ack_delay` but before receiving an ACK-FREQUENCY frame. This should not happen... the goal of `min_ack_delay` is to negotiate future use of ACK-FREQUENCY frames. Until an ACK-FREQUENCY frame is received, an endpoint continues with RFC 9000 behavior. We will add text to this effect.\r\n\r\n@huitema, does this work for you?",
          "createdAt": "2021-07-19T20:22:52Z",
          "updatedAt": "2021-07-19T20:24:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@janaiyengar yes, that makes sense. I will check that the picoquic code does that.",
          "createdAt": "2021-07-20T19:39:13Z",
          "updatedAt": "2021-07-20T19:39:13Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU1NTkwMTAzMzM=",
      "title": "min_ack_delay=0 in TP parameter ",
      "url": "https://github.com/quicwg/ack-frequency/issues/26",
      "state": "CLOSED",
      "author": "junhochoi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> Values of 0 and 2^24 or greater are invalid\r\n\r\nI think min_ack_delay=0 should be allowed? It means there is no delay sending ack, which is a current behavior.",
      "createdAt": "2020-02-03T11:07:20Z",
      "updatedAt": "2020-02-06T07:11:18Z",
      "closedAt": "2020-02-06T07:11:18Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "0 is equivalent to 1 as a value for the \"Packet Tolerance\" field I believe, so I agree that declaring it invalid seems unnecessary.  Also, 0 and 1 are extremely similar given this is in microseconds, and 1 is valid.",
          "createdAt": "2020-02-03T11:11:48Z",
          "updatedAt": "2020-02-03T11:11:48Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "0 and 1 are different, since 0 is immediate, and 1 involves a timer. Though, yeah, it seems silly to disallow immediate.",
          "createdAt": "2020-02-06T07:10:58Z",
          "updatedAt": "2020-02-06T07:10:58Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU1NjA4MTgzMDI=",
      "title": "Packet Tolerance is a non-obvious name",
      "url": "https://github.com/quicwg/ack-frequency/issues/27",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "editorial"
      ],
      "body": "By itself, it's not obvious(at least to me), what the field indicates without reading the description.\r\n\r\nAn alternate suggestion is \"Packet threshold\", since recovery calls it \"Packet threshold loss detection\".\r\n \r\n This is pretty clearly editorial.",
      "createdAt": "2020-02-06T07:00:59Z",
      "updatedAt": "2021-07-29T14:39:25Z",
      "closedAt": "2021-07-29T14:39:25Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "The use of it in loss detection is why I didn't call it packet threshold, to avoid confusion. But I agree that packet threshold is more natural... if you don't think this will cause confusion, I'm fine with it.",
          "createdAt": "2020-02-06T07:08:03Z",
          "updatedAt": "2020-02-06T07:08:03Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, how about \"Update Packet Threshold\" to align with \"Update Max Ack Delay\"?",
          "createdAt": "2020-02-06T07:14:05Z",
          "updatedAt": "2020-02-06T07:14:05Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "s/Update/New/?",
          "createdAt": "2020-02-06T08:12:52Z",
          "updatedAt": "2020-02-06T08:12:52Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Both SGTM",
          "createdAt": "2020-02-06T08:34:47Z",
          "updatedAt": "2020-02-06T08:34:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, let me think more, after starting a PR, I think packet threshold would be confusing.",
          "createdAt": "2020-02-06T08:46:16Z",
          "updatedAt": "2020-02-06T08:46:16Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Do we need \"update_\" in every field name? That seems excessive to me.\r\n\r\nIf we do think that we'd need to have the word somewhere, I think my preference goes to to changing the name of the frame to \"update_ack_frequency,\" and refrain from having \"update_\" in each field name.",
          "createdAt": "2020-04-07T01:51:26Z",
          "updatedAt": "2020-04-07T01:51:26Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "[Currently](https://tools.ietf.org/html/draft-iyengar-quic-delayed-ack-00), the draft states:\r\n\r\n```\r\n   Packet Tolerance:  A variable-length integer representing the maximum\r\n      number of ack-eliciting packets after which the receiver sends an\r\n      acknowledgement.  A value of 1 will result in an acknowledgement\r\n      being sent for every ack-eliciting packet received.  A value of 0\r\n      is invalid.\r\n```\r\n\r\nWe see that \"packet\" is a unit of measure; what it measures is the threshold after which an ACK is sent.  A better name would be _ACK-eliciting threshold_.  The fact that it represents a number of packets does not have to be in the name itself.",
          "createdAt": "2020-04-07T12:57:12Z",
          "updatedAt": "2020-04-07T12:57:12Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "ACK-eliciting threshold does seem better.  Or even Ack threshold.\r\n\r\n@kazuho changing the frame to UPDATE_ACK_FREQUENCY and then removing update_ from the names WFM.",
          "createdAt": "2020-04-07T18:33:07Z",
          "updatedAt": "2020-04-07T18:33:07Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "How about _ACK_FREQUENCY_UPDATE_, then?  This way, you can still write the frame type as an abbreviation, `0xAFu`!",
          "createdAt": "2020-04-07T18:40:44Z",
          "updatedAt": "2020-04-07T18:40:44Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Do we need \"update\" at all?\r\n\r\nI think we can simply say that an \"ACK_FREQUENCY\" frame updates how frequent ACK frames are sent.\r\n\r\nConsider MAX_STREAMS. The frame name does not include \"update\". It's implied. The same goes to the field name. The name is simply \"maximum streams.\" We can follow that convention.",
          "createdAt": "2020-04-07T19:05:54Z",
          "updatedAt": "2020-04-07T19:05:54Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with @kazuho on not including UPDATE in the name. Updating is implicit in the semantics of this frame, as it is not an informative frame.\r\n\r\nI also prefer ACK-eliciting threshold to just ACK threshold. ACK-eliciting threshold makes it clear that the threshold is against ACK-eliciting packets, which are well-defined.",
          "createdAt": "2020-04-29T16:38:34Z",
          "updatedAt": "2020-04-29T16:38:34Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Both changes SGTM (remove \"Update\" and change to \"Ack-eliciting Threshold\")",
          "createdAt": "2021-07-12T17:40:17Z",
          "updatedAt": "2021-07-12T17:40:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "One potential issue with changing 'Update Max Ack Delay' to 'Max Ack Delay' is it could be confused with the 'max_ack_delay' transport param.",
          "createdAt": "2021-07-12T17:44:08Z",
          "updatedAt": "2021-07-12T17:44:08Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we do need clarity here. An endpoint advertizes its own max_ack_delay in the TP, but the ACK-FREQUENCY frame is a command or request to the peer to change the peer's advertized value.",
          "createdAt": "2021-07-19T20:31:28Z",
          "updatedAt": "2021-07-19T20:31:28Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@janaiyengar and I were talking and are worried about confusion on this one.\r\n\r\nOne suggestion is \"Request Max Ack Delay\"",
          "createdAt": "2021-07-19T20:32:21Z",
          "updatedAt": "2021-07-19T20:32:21Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU1NjIwMDQxNTQ=",
      "title": "Make it more clear that implementations can send less ACKs",
      "url": "https://github.com/quicwg/ack-frequency/issues/30",
      "state": "CLOSED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "needs-pr"
      ],
      "body": "As discussed with @janaiyengar a couple days ago, I think the draft should make it clear that implementations are allowed to send less ACKs than the requested \"packet tolerance\".\r\n\r\n> 6.3.  Batch Processing of Packets\r\n>   For performance reasons, an endpoint can receive incoming packets\r\n>   from the underlying platform in a batch of multiple packets.  This\r\n>   batch can contain enough packets to cause multiple acknowledgements\r\n>   to be sent.\r\n>\r\n>   To avoid sending multiple acknowledgements in rapid succession, an\r\n>   endpoint MAY process all packets in a batch before determining\r\n>   whether a threshold has been met and an acknowledgement is to be sent\r\n>   in response.\r\n\r\nThe last paragraph is a bit unclear since \"threshold\" is undefined.  I think we should just say that:\r\n\r\n1) it MAY process all packets in a batch (already there)\r\n2) it MAY send less ACKs when it has finished processing the batch\r\n\r\n",
      "createdAt": "2020-02-08T11:02:23Z",
      "updatedAt": "2021-10-01T20:36:49Z",
      "closedAt": "2021-10-01T20:36:49Z",
      "comments": [
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Already clarified in RFC 9000.",
          "createdAt": "2021-10-01T20:36:49Z",
          "updatedAt": "2021-10-01T20:36:49Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU1OTYzMDU2MzM=",
      "title": "ignore_order vs. inducing ack on PTO (aka IMMEDIATE_ACK)",
      "url": "https://github.com/quicwg/ack-frequency/issues/34",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "When sending a PTO packet, a sender wants to induce an immediate ACK. The only trick I know to induce such an ACK is intentionally skip the packet number.\r\n\r\nHowever, the problem of that approach is that it relies on the receiver not ignoring reorders.\r\n\r\nWhen an ACK_FREQUENCY frame previously sent had set the `ignore_order` bit, then it become impossible for a sender to induce an immediate ACK when sending a PTO packet.\r\n\r\nAt the moment, the only solution is to bundle an ACK_FREQUENCY packet in each PTO packet, but that seems like a bit of unnecessary overhead to me. Should we have a dedicated frame for inducing immediate ACKs instead?",
      "createdAt": "2020-04-08T04:48:29Z",
      "updatedAt": "2021-09-15T23:28:30Z",
      "closedAt": "2021-09-15T23:28:30Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an option.  Another option is to revisit the max_reordering idea discussed in #18.\r\n\r\nIf the max reordering was 5, then you could skip 5 PNs.  I do feel like it'd be nice to allow specifying an int for max reordering, since that matches up with adaptive packet threshold loss detection, but as I expressed in #18, I think getting the details right are deceptively difficult, so I'm torn.",
          "createdAt": "2020-04-08T14:00:56Z",
          "updatedAt": "2020-04-08T14:00:56Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This does seem like a real problem. I like the idea of a single \"ELICIT_ACK\" type frame. With one byte a sender could effectively mark its PTOs ensuring they get an ACK without relying on the trick.\r\n\r\nAn explicit frame is also easier to implement for the sender than the packet number skipping.",
          "createdAt": "2020-04-29T16:49:47Z",
          "updatedAt": "2020-04-29T16:49:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There's quite a bit of discussion on this on the tcpm mailing list at the moment, ie: https://mailarchive.ietf.org/arch/browse/tcpm/?gbt=1&index=OlHjbLuquYYe7twVPuZBHqbBph8\r\n\r\nI'm increasingly thinking it's worth using an unused protected bit in the header for this.  It'd end up competing with the 2-bit packet loss measurements, but given those are experimental and may never be widely deployed, I think it might be worth it.\r\n\r\nFor example, I believe this could allow an implementation to not include max_ack_delay in PTO if it set the \"ACK-pull\"(or whatever it's called) bit on the final packet.  That already seems possible if more than the threshold number of ack-eliciting packets are outstanding.",
          "createdAt": "2020-05-02T20:51:35Z",
          "updatedAt": "2020-05-02T20:51:35Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I've thought more about this, and I think most of the time a 1-byte frame would be acceptable, but it definitely adds some implementation complexity, so I'd be curious which design others prefer?  If we can decide, then I'll be happy to write a PR(or @kazuho can).\r\n\r\nBesides PTO, a use case would be making the last packet before becoming app-limited elicit an immediate ACK.  This could allow skipping max_ack_delay for all PTOs(see #37), though always doing it could be a bit much in some cases.  For example, browsers commonly send a series of requests, but to the transport it seems app-limited between them, because it doesn't know the browser has another request to send.\r\n\r\nIt might be useful for 'chirping' as well, but I've never tried that, so it's mostly speculation.",
          "createdAt": "2020-05-03T20:34:58Z",
          "updatedAt": "2020-05-03T20:36:04Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm increasingly thinking it's worth using an unused protected bit in the header for this. It'd end up competing with the 2-bit packet loss measurements, but given those are experimental and may never be widely deployed, I think it might be worth it.\r\n\r\nWe don't currently have any intention of deploying them either, and I think that's unlikely to change. I haven't seen a lot of good evidence that they are terribly helpful, and content providers don't seem to have a good incentive for implementing it. \r\n\r\n> I've thought more about this, and I think most of the time a 1-byte frame would be acceptable, but it definitely adds some implementation complexity, so I'd be curious which design others prefer? If we can decide, then I'll be happy to write a PR\r\n\r\nFor us at least, the difference in complexity for a frame versus a bit in the header is negligible. A frame is actually be slightly easier to implement and losing a byte here and there isn't so bad.",
          "createdAt": "2020-05-05T23:32:12Z",
          "updatedAt": "2020-05-06T00:00:01Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I've thought more about this, and I think most of the time a 1-byte frame would be acceptable, but it definitely adds some implementation complexity, so I'd be curious which design others prefer?\r\n\r\nI strongly prefer using the header bit. Although it will be a bit more work to implement, the fact that I won't end up with a 1-byte STREAM frame that I have to split off at the end of the packet will be worth the effort.",
          "createdAt": "2020-05-06T01:02:48Z",
          "updatedAt": "2020-05-06T01:02:48Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": ">>   I'm increasingly thinking it's worth using an unused protected bit in the header for this. It'd end up competing with the 2-bit packet loss measurements, but given those are experimental and may never be widely deployed, I think it might be worth it.\r\n>\r\n> We don't currently have any intention of deploying them either, and I think that's unlikely to change. **I haven't seen a lot of good evidence that they are terribly helpful**\r\n\r\nIs testimony of network operators not taken as evidence?  I remember a line of people, from different companies -- BT, ATT, and so on, at IETF 101 practically begging for some information in QUIC packets to be exposed for monitoring and troubleshooting.",
          "createdAt": "2020-08-07T11:59:47Z",
          "updatedAt": "2020-08-07T11:59:47Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "> I strongly prefer using the header bit. Although it will be a bit more work to implement, the fact that I won't end up with a 1-byte STREAM frame that I have to split off at the end of the packet will be worth the effort.\r\n\r\nI do not see anyone propose a 1-byte *STREAM* frame.  I believe what is meant is a new frame type.\r\n\r\nIf anything, using a new frame type to elicit an ACK is easier than using a header bit, as it involves fewer parts of the code to change.",
          "createdAt": "2020-08-07T12:08:36Z",
          "updatedAt": "2020-08-07T12:08:36Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I do not see anyone propose a 1-byte STREAM frame. I believe what is meant is a new frame type.\r\n\r\nNobody is proposing a 1-byte STREAM frame (you can't just make up stream data anyway). \r\nThe problem is that a new frame would consume bytes (or probably one byte) in the packet payload. Given that you set this signal on a PTO, and PTOs are often retransmissions of packets, this would require you to repackage (and, most likely, cut off a single byte from a STREAM frame). Using a header bit would solve that problem.",
          "createdAt": "2020-08-07T12:29:40Z",
          "updatedAt": "2020-08-07T12:29:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@janaiyengar and I discussed this and there are number of ways to fix this, but given this issue of not being able to elicit an immediate ACK by skipping packet numbers is introduced by the draft, we feel it's important it be fixed in some way.\r\n\r\nOne more option is new STREAM frame codepoints that elicit an immediate ACK.",
          "createdAt": "2021-07-19T20:50:57Z",
          "updatedAt": "2021-07-19T20:50:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm ready to write a PR, but I'd appreciate thoughts on whether the existing PING frame should be repurposed or we should add a new frame(ACK, PONG, etc).\r\n\r\nI lean towards a new frame, since there are enough code-points and I believe there are use cases for the existing PING frame that does not elicit an immediate ACK.",
          "createdAt": "2021-07-31T01:29:37Z",
          "updatedAt": "2021-07-31T01:29:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "> I lean towards a new frame, since there are enough code-points and I believe there are use cases for the existing PING frame that does not elicit an immediate ACK.\r\n\r\n+1. While I would not be opposed to repurposing the existing PING frame, I do not see the necessity of doing that. Let's simply consume one code point of the remaining 33.",
          "createdAt": "2021-08-02T02:05:36Z",
          "updatedAt": "2021-08-02T02:05:36Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, now for bikeshedding time.\r\n\r\nSome possible names:\r\n ACK_ME\r\n ACK_PULL (from TCP)\r\n FAST_ACK\r\n PONG",
          "createdAt": "2021-08-02T15:36:11Z",
          "updatedAt": "2021-08-02T15:36:11Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Putting on my bikeshedding hat:\r\n\r\nI don't think we should prefix the frame name with ACK_ since that almost makes it looks like yet another variant of the ACK frame.\r\n\r\nThe \"pull\" TCP terminology is fine (e.g. PULL_ACK) but we could also be more explicit with something like SOLICIT_ACK.",
          "createdAt": "2021-08-02T18:22:44Z",
          "updatedAt": "2021-08-02T18:22:44Z"
        },
        {
          "author": "msvoelker",
          "authorAssociation": "NONE",
          "body": "SCTP has something similar and calls it SACK-IMMEDIATELY (RFC 7053).",
          "createdAt": "2021-08-04T13:56:09Z",
          "updatedAt": "2021-08-04T13:56:09Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I'd be happy with ACK_IMMEDIATELY or IMMEDIATE_ACK",
          "createdAt": "2021-08-04T14:48:01Z",
          "updatedAt": "2021-08-04T14:48:01Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For those two options I'd prefer IMMEDIATE_ACK for the same reasoning as above -- so it appears less like an ACK variant.",
          "createdAt": "2021-08-04T21:06:43Z",
          "updatedAt": "2021-08-04T21:06:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "IMMEDIATE_ACK sounds good to me. Alternatively, I'd be also fine with something like ACK_NOW.",
          "createdAt": "2021-08-04T21:14:56Z",
          "updatedAt": "2021-08-04T21:14:56Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "IMMEDIATE_ACK it is, PR coming.",
          "createdAt": "2021-09-08T12:19:34Z",
          "updatedAt": "2021-09-08T12:19:34Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU2MDI1NDQyMjY=",
      "title": "Replace Ignore Order with Packet Threshold",
      "url": "https://github.com/quicwg/ack-frequency/issues/35",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "design",
        "needs-discussion"
      ],
      "body": "Issue #34 points out that if ignore_order is true, there's no way to get an immediate ACK(for PTO or otherwise).\r\n\r\nThis proposal is very similar to that discussed in #18, but I believe I can specify both how to implement it and how it could be used better than I was able to previously.\r\n\r\nI believe there's a straightforward use case every implementation can benefit from, which is communicating one's packet threshold for loss detection.\r\n\r\nI previously presented data at maprg which showed about half of reordering is twiddles(reorder of 1), so having some tolerance for it can reduce the number of unnecessary immediate acks substantially.  In order for this to not delay loss detection in some cases, the ack_delay field needs to be no larger than the time threshold for loss detection, which could be a limitation depending upon min_ack_delay, but I would typically expect to be fine.\r\n\r\nThe field could also be used for other use cases where packets aren't always sent in order, but that doesn't need to be explained in this draft.\r\n\r\nFor implementation, on every ack-eliciting packet:\r\n- If it's smaller than the largest acked in the last sent ack frame, send an immediate ACK because it fills a hole.\r\n- If it's larger than the last sent largest acked, only send an immediate ACK if there are missing packets greater than the last sent largest acked that are at least packet_threshold away from the current largest received packet.\r\n\r\nThis speeds up loss detection very slightly vs the core transport draft if the packet reordering threshold isn't an odd number, because the ACK is sent exactly when the sender will be able to use it to declare a loss.",
      "createdAt": "2020-04-18T20:24:57Z",
      "updatedAt": "2021-09-10T16:26:52Z",
      "closedAt": "2021-09-10T16:26:52Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Thank you for opening the issue, I think this is the correct direction.\r\n\r\nHaving a way to specify a threshold is nothing but improvement from just having a boolean. I do not think there is a reason to object against changing the field to a threshold, based on the assumption that there is a use-case (as you describe).\r\n\r\nTo be clear, I am not excited about using reorder threshold for incuding ACKs when sending PTOs, because skipping _N_ is uglier than skipping 1, considering the fact that N (i.e. the threshold) might or not have been delivered to the peer. But that's a complaint against reusing this mechanism for inducing ACKs, and not an argument against changing the boolean flag to a threshold.",
          "createdAt": "2020-04-21T23:15:10Z",
          "updatedAt": "2020-04-21T23:15:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your thoughts and support @kazuho \r\n\r\nI agree that this is not an ideal fix for #34 and we may want to do more than this.",
          "createdAt": "2020-04-22T18:57:01Z",
          "updatedAt": "2020-04-22T18:57:01Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that an explicit threshold is strictly better than a boolean. The only problem is one of naming, where we now have two things that are arguably thresholds, where only one is titled as such (\"Packet Loss Threshold\" and \"Packet Tolerance\" )\ud83d\ude42 , but that's a bikeshed for #27.\r\n\r\n\r\n\r\n",
          "createdAt": "2020-04-29T16:35:17Z",
          "updatedAt": "2020-04-29T16:35:17Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is probably fine. This does put a larger burden on the receiver (a sender can simply set the variable to 0), but as I noted in [this comment](https://github.com/janaiyengar/ack-frequency/issues/18#issuecomment-578361546) on #18, the receiver can be reasonably simple too.\r\n\r\nI agree that it doesn't seem great though to solve this particular problem... in addition to requiring skipping N packets at the sender, it also means that when wanting an immediate ACK, a sender that would otherwise use 0 (ignore order) will now have to send two ACK_FREQUENCY frames: one to elicit the immediate ACK, and another later to set the ignore order back again. I'll think about this a bit more.",
          "createdAt": "2020-05-01T23:19:45Z",
          "updatedAt": "2020-05-01T23:19:45Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "How about if we simply say that the receiver always ACKs PINGs immediately? Does that solve the immediate ACK on PTO problem?",
          "createdAt": "2020-05-01T23:20:47Z",
          "updatedAt": "2020-05-01T23:20:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "ACKing PINGs immediately seems sensible and this question has come up before(I believe Igor raised it).  At the moment, PINGs exist to elicit an ACK and I don't think they have any other purpose?  There may need to be some rate-limit on immediate ACKs(ie: ACK within kGranularity rather than 'immediately'), but I think we have text that indicates waiting for kGranularity still counts as 'immediate'.\r\n\r\nChanging the response to PING would be a change to the core spec, so I'd suggest you create an issue immediately if we're going to do that.  In an ideal world, it wouldn't consume a byte, since that can make retransmission logic more complex(ie: do I include a PING with my PTO and remove a byte of payload or just send the full payload).  We have 2 unused bits in the header, so we could use one of those if we wanted.  That could be an extension, though it'd end up competing with the loss bits.\r\n\r\nBut this entire comment relates to #34 more than this issue.",
          "createdAt": "2020-05-02T00:58:08Z",
          "updatedAt": "2020-05-02T00:58:08Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "> Changing the response to PING would be a change to the core spec\r\n\r\nCan't we simply limit this change to PING to when this extension is negotiated?",
          "createdAt": "2020-08-07T12:23:13Z",
          "updatedAt": "2020-08-07T12:23:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "As you might be able to tell from the discussion on the pull request, I've spent a little time working on this.  I struggled to understand this proposal, because the way it is framed is confusing.  I believe that there is a much simpler way of describing and implementing this than is in the current draft (and the proposed change).\r\n\r\nThe current strategy has you immediately ACK for any Initial or Handshake packet, or any packet numbered lower than the largest acknowledged.  (You might also add a packet containing PING, which is reasonable.)  The draft should put those universal conditions for an immediate ACK in a separate section.  Right now, this is not very clear in the text.\r\n\r\nThen there are those packets that arrive after largest acknowledged.  The draft before this change covers packets that arrive perfectly in sequence.  For those, there are a certain number that arrive that don't get acknowledged.  If you get more than that, then you acknowledge immediately.  This is currently phrased differently, in that you acknowledge when you receive N.  \r\n\r\nThis issue proposes to cover the case where the packets you receive after largest acknowledged are NOT contiguous.  Phrased in that way, the number is the same as the packet threshold, but it only applies after there is a gap detected.\r\n\r\nThat leaves you with:\r\n\r\n![Immediate ACK conditions](https://user-images.githubusercontent.com/67641/89747912-38f2a680-db04-11ea-9d7d-430556a8933a.png)\r\n\r\nThat is, there is a window in which packets can arrive without generating an immediate acknowledgment.  I've found that thinking in those terms simplifies this a lot.\r\n\r\nWith this picture in mind, the special 0 value that Ian's pull request uses to disable the loss threshold isn't necessary.  You can disable the special loss threshold by setting that value to be the same as the packet threshold.  You might have to prohibit the loss threshold from exceeding the packet threshold just to avoid silly conditions where a gap causes more delays, but the receiver could just clamp the value.\r\n\r\nI am going to suggest that this be changed to the number of unacknowledged, contiguous packets so that you can remove 0 as an invalid value.  That is, of course, orthogonal; you can always add one, but you can see that this is not necessary.  As you can see from the diagram, if you want an immediate ACK always, it is easier to think of the window being 0 width than it is to think about the packet that you received.\r\n\r\nBTW, you can also think about the time component in the same way: there is a period of time during which you don't generate an immediate acknowledgment.  That isn't perfect, because you start that period when the first packet arrives, but it's not a *bad* fit.",
          "createdAt": "2020-08-10T02:35:17Z",
          "updatedAt": "2020-08-10T02:35:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "One thing to note about the above is that you need to skip all non-ack-eliciting packets that appear immediately after the largest acknowledged packet.  Our stack doesn't individually track whether a received packet is ack-eliciting or not, so our logic isn't perfect in that regard.  I believe you get close though if you increase \"largest acknowledged\" by one every time the next packet arrives and it isn't ack-eliciting.\r\n\r\nThen the logic is fairly simple:\r\n\r\n```python\r\n# def on_received(pn):\r\nranges.add(pn) # Track receipt.\r\n\r\nif space != ApplicationData:\r\n    immediate_ack = true\r\nelse if pn == ranges.largest.largest:\r\n    # This determines whether there is a gap in the unacknowledged packets.\r\n    if largest_acknowledged < ranges.largest.smallest:\r\n        threshold = loss_threshold\r\n    else:\r\n        threshold = packet_threshold\r\n    immediate_ack = pn > largest_acknowledged + threshold\r\nelse if pn < largest_acknowledged:\r\n    immediate_ack = true\r\nelse:\r\n    immediate_ack = false\r\n\r\nif ack_eliciting:\r\n    if immediate_ack:\r\n        send_ack(now)\r\n    else:\r\n        schedule_ack(now + ack_delay)\r\nelse if pn == largest_acknowledged + 1:\r\n    # Disregard this packet for later packet/loss threshold calculations.\r\n    largest_acknowledged = pn\r\n```",
          "createdAt": "2020-08-10T09:56:46Z",
          "updatedAt": "2020-08-10T09:57:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson I think that _almost_ works, but I am not sure if it's sufficient. It seems that the approach does not handle reordered packets that carry packet numbers below largest acked, and I think that might be a problem.\r\n\r\nLet's consider the following example. There are two paths from the server, with a difference of 10ms. The server sends a packet every millisecond. Odd-numbered packets are transferred on the faster path, even-numbered ones on the slower path. \"Packet Tolerance\" is set to 25 packets (1/8th of RTT).\r\n\r\n```\r\n   +------ 100ms ------+\r\n   v                   |\r\nserver --> 100ms --> client\r\n       --> 110ms -->\r\n```\r\n\r\nThe client will receive packets in the order of something like: 11, 2, 13, 4, 15, 6, 17, 8, 19, 10, 21, 12, 23, 14, 25, 16, 27, 18, 29, 20 ...\r\n\r\nWhat we want to achieve is:\r\n* When the reordering threshold is small (e.g., 5), this pattern should elicit one ack every 2 packets.\r\n* When the reordering threshold is above the reorder (e.g., 12), this pattern should elicit one ack every 25 packets.\r\n\r\nGoing back to the algorithm proposed in https://github.com/janaiyengar/ack-frequency/issues/35#issuecomment-671265305. Let's say that the client has sent an ack when it received 15. It will then go on to send acks when it receives packet 6, 8, 10, 12, 14, because the received packet number is below largest acked.\r\n\r\nIn this example, the proposed approach will emit 6 acks per 35 incoming packets, whereas what we want to see is 1 ack per 25 incoming packets.",
          "createdAt": "2020-08-12T07:50:50Z",
          "updatedAt": "2020-08-12T07:50:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "So I worked through that and concluded that in cases of severe reordering you do get a burst of acknowledgments.  And if you have consistent reordering that happens a lot.\r\n\r\nIn your case, at least at the beginning, you will accumulate packets up to some number before you hit the reordering threshold and send an immediate ACK.  A reordering threshold less than 10 results in an ACK for every packet, but that's the intent, is it not?\r\n\r\nAs for the 6, 10, 10, 12, 14 being immediately acknowledged, this is based on this text in Ian's proposed resolution to this issue:\r\n\r\n> [...], implementations MUST still immediately acknowledge any received packets with packet numbers smaller than the largest 'Largest Acked' value previously sent in an ACK frame.\r\n\r\nI just accepted this premise as valid, but I see that it might not be.  In this example, it doesn't matter what is acknowledged, the next packet (and every other) will result in an immediate ACK.\r\n\r\nAnother scenario, perhaps a more realistic scenario one, is the one where a single packet (a small packet at the tail of a sequence of larger packets) is significantly reordered.  If you have 40 packets in flight and the last one jumps ahead of 23 of them, then this algorithm might be OK or it might not.  If it sees that packet 40 is preceded by 23 gaps, and it has acknowledged something past packet 15, then it will let the gap fill in if the loss threshold is 22 or 23.  If it acknowledged anything less than 15, it will immediately acknowledge 40 and then generate an immediate ACK for every packet that arrives as the gap is filled.  The huge variation between those cases is a little worrying.\r\n\r\nIf instead we count unacknowledged, ack-eliciting packets then we get something different.  You count each arriving ack-eliciting packet toward both thresholds if (? algorithm), but only toward the packet threshold if there is not.  We don't care about the largest acknowledged, just newly arriving packets.\r\n\r\nThe algorithm that I might use for that might look like:\r\n\r\n```python\r\n# def on_received(pn):\r\nexpected = ranges.largest.largest + 1\r\nranges.add(pn) # Track receipt.\r\n\r\n# Assuming that the packet was ack-eliciting...\r\nif space != ApplicationData:\r\n    immediate_ack = true\r\nelse:\r\n    out_of_order ||= pn != expected:\r\n    unacknowledged += 1\r\n    if out_of_order:\r\n        immediate_ack = unacknowledged > loss_threshold\r\n    else:\r\n        immediate_ack = unacknowledged > packet_threshold\r\n```\r\n\r\nThis doesn't consider the largest acknowledged at all.\r\n\r\nDoes that sound better?",
          "createdAt": "2020-08-12T09:45:42Z",
          "updatedAt": "2020-08-12T09:45:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson Thank you for the response.\r\n\r\nI think it might be better to take a step back and discuss what we want to achieve, before discussing how things can be implemented.\r\n\r\n> In your case, at least at the beginning, you will accumulate packets up to some number before you hit the reordering threshold and send an immediate ACK. A reordering threshold less than 10 results in an ACK for every packet, but that's the intent, is it not?\r\n\r\nWe do not expect to see that. In our case (sending HTTP responses from different nodes within a server cluster), we would know when we would start sending from multiple nodes, and when we would stop doing so. Therefore, we can increase reordering threshold when we are about to enter that mode, reduce the threshold when we exit.\r\n\r\nConsider the case of sending two incremental responses from two nodes. Assuming that the prioritization logic would designate different QUIC streams for every packetiztaition opportunity, we will see the pattern that I used as the example; half of the packets (e.g., odd-numbered) sent from one cluster node arrive earlier (or later) than those sent from the other.\r\n\r\n> Another scenario, perhaps a more realistic scenario one, is the one where a single packet (a small packet at the tail of a sequence of larger packets) is significantly reordered.\r\n\r\nWe expect to see this pattern, when the coordinator node within the cluster sends ACKs, while all the ack-eliciting packets are sent by a different node.\r\n\r\nAt the moment, the draft has `ignore_order` bit, and it covers these use-cases fairly well. For us, setting the ignore bit and relying on packet threshold (which would be set to 1/8th of CWND) would work fine.\r\n\r\nAs stated in [my earlier comment](https://github.com/janaiyengar/ack-frequency/issues/35#issuecomment-617459893), my strong desire is that the switch from a boolean to an integer, assuming that would happen, would not cause regression regarding these use-cases.",
          "createdAt": "2020-08-12T10:38:24Z",
          "updatedAt": "2020-08-12T10:38:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Based on this feedback, I think that the simpler scheme this envisages is much better than what I earlier suggested.  So I am now of the opinion that this issue should be closed without changing the spec.",
          "createdAt": "2021-04-07T22:36:32Z",
          "updatedAt": "2021-04-07T22:36:32Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing editors' discussion: We believe that there might be some non-zero performance benefits in doing packet_threshold, but there is clearly high cognitive complexity and therefore unknown issues. At this time, we believe that retaining ignore_order allows us to move forward, and if there is more information that shows the value of doing more, we will revisit this issue.\r\n\r\n(To be discussed at IETF.)",
          "createdAt": "2021-07-19T20:56:40Z",
          "updatedAt": "2021-07-19T20:56:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Until there's evidence this is valuable for performance, closing this.",
          "createdAt": "2021-09-10T16:26:52Z",
          "updatedAt": "2021-09-10T16:26:52Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU2MTE0OTk3NzU=",
      "title": "Allow using kGranularity instead of max_ack_delay in PTO calculation",
      "url": "https://github.com/quicwg/ack-frequency/issues/37",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "With this extension, an immediate ACK is expected if more than the \"Packet Tolerance\" ack-eliciting packets are outstanding.  Given that, it may be a worthwhile optimization to allow the max_ack_delay to not be included in the PTO computation in some cases.  If we're not going to allow that, I think we should explain why.\r\n\r\nhttps://github.com/janaiyengar/ack-frequency/blob/master/draft-iyengar-quic-delayed-ack.md#computation-of-probe-timeout-period\r\n\r\nThis split off #34, but I think the question of whether max_ack_delay always needs to be included in PTO should be separate from whether QUIC would benefit from an ACK-pull mechanism of some sort.  That being said, if a mechanism did exist, we add details about when ACK-pull allowed max_ack_delay to not be included.",
      "createdAt": "2020-05-03T20:26:32Z",
      "updatedAt": "2021-09-10T07:15:35Z",
      "closedAt": "2021-09-10T07:15:35Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a clever optimization, I agree it's worth some text.",
          "createdAt": "2021-07-19T20:59:08Z",
          "updatedAt": "2021-07-19T20:59:08Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU2NDEwMjc5OTc=",
      "title": "What about ack decimation?",
      "url": "https://github.com/quicwg/ack-frequency/issues/38",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Chrome has [some logic](https://source.chromium.org/chromium/chromium/src/+/master:net/third_party/quiche/src/quic/core/quic_received_packet_manager.cc;l=284-287) to delay sending of an immediate acknowledgement for reordered packets. This reduces the number of ACKs sent, since, if I remember @ianswett's presentation in mapgr correctly, most of the packet reorderings are just one packet number apart from each other.\r\n\r\nDo we need something like this?",
      "createdAt": "2020-06-18T08:49:07Z",
      "updatedAt": "2021-09-10T16:25:52Z",
      "closedAt": "2021-09-10T16:25:52Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This didn't end up being that useful in practice(application metrics were slightly worse), so it's in the process of being removed.\r\n\r\nI think it turns out sending an extra ACK for an occasional twiddle just isn't that costly.",
          "createdAt": "2020-07-27T19:33:23Z",
          "updatedAt": "2020-07-27T19:33:23Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing editors' discussion: This is a variation on `ignore_order`, and the proposed resolution is similar to #35: go with simple `ignore_order` until we have new data/information.",
          "createdAt": "2021-07-19T21:07:17Z",
          "updatedAt": "2021-07-19T21:07:17Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU3MTUwOTAwMjk=",
      "title": "Specify whether storing min_ack_delay TP is mandatory",
      "url": "https://github.com/quicwg/ack-frequency/issues/40",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "The transport I-D 31 [states](https://tools.ietf.org/html/draft-ietf-quic-transport-31#section-7.4.1):\r\n\r\n```\r\n   The definition of a new transport parameter (Section 7.4.2) MUST\r\n   specify whether storing the transport parameter for 0-RTT is\r\n   mandatory, optional, or prohibited.  A client need not store a\r\n   transport parameter it cannot process.\r\n```\r\n\r\nThis information is missing from [draft-iyengar-quic-delayed-ack-01](https://tools.ietf.org/html/draft-iyengar-quic-delayed-ack-01).",
      "createdAt": "2020-10-05T19:08:26Z",
      "updatedAt": "2021-09-10T16:24:45Z",
      "closedAt": "2021-09-10T16:24:45Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "FWIW, I tend to think that this issue is coupled with #22, and that endpoints do not need to, due to the reasons being explained on that issue.",
          "createdAt": "2020-11-03T02:16:17Z",
          "updatedAt": "2020-11-03T02:16:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #63",
          "createdAt": "2021-09-10T16:24:45Z",
          "updatedAt": "2021-09-10T16:24:45Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU3MzQ5MzIxNDY=",
      "title": "Directionality of the negotiation",
      "url": "https://github.com/quicwg/ack-frequency/issues/42",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "To me it seems that the draft can be interpreted in the following two ways. It would be great if there was a clarification regarding which is correct:\r\n\r\n* `min_ack_delay` TP is a declaration that the endpoint will recognize ACK_FREQUENCY frames. The receiver of the TP can send ACK_FREQUENCY frames regardless of it sending `min_ack_delay` TP or not.\r\n* Use of delayed acks are negotiated by both endpoints sending `min_ack_delay` TP. ACK_FREQUENCY frames can be used only when the both endpoints send the TP.\r\n\r\nI assume that the intent to be the latter, but I'm not sure.",
      "createdAt": "2020-11-03T00:34:12Z",
      "updatedAt": "2021-04-19T18:37:46Z",
      "closedAt": "2021-04-19T18:37:46Z",
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting, I actually interpreted it to be the former. I think it is reasonable for an implementation to accept ACK_FREQUENCY without having any intention of sending them itself. I.e. I don't see any reason it has to be mutually negotiated. ",
          "createdAt": "2020-11-03T04:09:52Z",
          "updatedAt": "2020-11-03T04:09:52Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "I agree that it's totally fine to consider the use being allowed independently for each direction. Though, for the ease of testing, I might prefer the use being negotiated mutually. It's a bit complex to have two flags; one that emits the min_ack_delay TP and another that controls the recognition of that TP sent by the peer.\r\n\r\nEndpoints that are not interested in sending ACK_FREQUENCY frames can just send the min_ack_delay TP ~with the value set to max_ack_delay~.",
          "createdAt": "2020-11-03T04:37:50Z",
          "updatedAt": "2020-11-03T04:51:06Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@mjoras -- that's not quite right. If this were unilateral, that would mean that an endpoint that _receives_ the TP would not need to advertise the TP. That's a bit confusing, since the endpoint that sends the TP intends to use the ACK_FREQUENCY frame, which it wouldn't then be able to do.\r\n\r\nThe most straightforward interpretation is the second one that @kazuho proposes.",
          "createdAt": "2020-11-06T03:44:11Z",
          "updatedAt": "2020-11-06T03:44:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "> That's a bit confusing, since the endpoint that sends the TP intends to use the ACK_FREQUENCY frame, which it wouldn't then be able to do.\r\n\r\nI think it can be quite natural depending on how you see it. We can define the TP as a proclamation by an endpoint to respect ACK_FREQUENCY frames. I would also point out that most (maybe all) transport parameters are unilateral declarations of endpoint properties, rather than a negotiation.\r\n\r\nThat said, with either of the approaches, it is impossible for an endpoint to declare support for multiple versions. I'm not sure if that's required, but it might be necessary. If we want to support multiple versions, then, we can either:\r\n* Say that each endpoint unilaterally declares it's capabilities (or supported versions); then the peer chooses what to use and sends the chosen capability (or the version) using a frame, much like how ALPN is being selected.\r\n* Say that the support for delayed-ack is negotiated by both endpoints. Each endpoints send a list of supported versions, and we define a logic for choosing one from the lists provided by both endpoints.\r\n\r\nPersonally, I think I prefer the former, especially if we are to negotiate use of multiple extensions at once. But the necessity is still unclear.",
          "createdAt": "2020-11-07T08:28:59Z",
          "updatedAt": "2020-11-07T08:29:11Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think it can be quite natural depending on how you see it. We can define the TP as a proclamation by an endpoint to respect\r\n> ACK_FREQUENCY frames. I would also point out that most (maybe all) transport parameters are unilateral declarations of\r\n> endpoint properties, rather than a negotiation.\r\n\r\nAh. I clearly misread what @mjoras was saying.  Yeah, this does align with the rest of the TPs, and it also aligns well with the intent of this TP -- each endpoint has to declare that it will respect and act on an ACK_FREQUENCY frame when one is received.\r\n\r\nI like the unilateral declaration of capabilites. I don't think we will need to support multiple versions in the longer term, but it's worth supporting if it isn't difficult to do. And in this case, I think it naturally aligns well with the intent of the frame.\r\n",
          "createdAt": "2020-11-09T00:24:54Z",
          "updatedAt": "2020-11-09T00:24:54Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There's been no change on this in a while, so I'm planning to merge @nibanks PR soon unless someone speaks up.",
          "createdAt": "2021-04-15T16:24:50Z",
          "updatedAt": "2021-04-15T16:24:50Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU3ODMwOTkyMjM=",
      "title": "Does the maximum max_ack_delay value apply to \"Update Max Ack Delay\"?",
      "url": "https://github.com/quicwg/ack-frequency/issues/43",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "QUIC Transport specifies a maximum value of 2^14 ms (roughly 16s) for the `max_ack_delay` transport parameter. Does this limit apply to values sent in the `Update Max Ack Delay` field of the ACK_FREQUENCY frame, or is any value up to 2^62 microseconds allowed here?\r\nEither way, the draft might benefit from clarifying the rules here.",
      "createdAt": "2021-01-11T06:18:48Z",
      "updatedAt": "2021-07-31T01:15:51Z",
      "closedAt": "2021-07-31T01:15:51Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The editors do not have a strong opinion, and we currently say nothing about the limit being changed by this extension, so we're inclined to keep the limit as is and add some text clarifying that the extension doesn't change the limit.\r\n\r\nWe're open to arguments otherwise if people have them.",
          "createdAt": "2021-07-22T20:08:16Z",
          "updatedAt": "2021-07-22T20:08:33Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU3ODMxNDQ2MDc=",
      "title": "min_ack_delay allows encoding of values larger than the maximum max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/issues/44",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "If I understand correctly, the maximum value of the `min_ack_delay` transport parameter is supposed to ensure that the value is smaller or equal than the `max_ack_delay` transport parameter.\r\n\r\nAccording to [QUIC-TRANSPORT Section 18.1](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#name-reserved-transport-paramete) the maximum value of `max_ack_delay` is `(2^14 - 1) ms = 16,383,000 \u03bcs`. However, the maximum value of `min_ack_delay` is `(2^24 - 1) \u03bcs = 16,777,215 \u03bcs`.",
      "createdAt": "2021-01-11T07:43:30Z",
      "updatedAt": "2021-07-31T01:15:51Z",
      "closedAt": "2021-07-31T01:15:51Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We're going to remove the 2^24 - 1 limit and just rely on the MUST that min_ack_delay can't be greater than max_ack_delay, which implies the 2^14-1 limit.",
          "createdAt": "2021-07-22T20:13:03Z",
          "updatedAt": "2021-07-22T20:13:03Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4MjAyNjgyMjU=",
      "title": "Maximum Values for Frame Fields",
      "url": "https://github.com/quicwg/ack-frequency/issues/45",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Does it make sense to specify any maximum values for any of the ACK frequency frame fields, such as for Packet Tolerance? Does a value of 4 billion make sense? Can I use a `uint8_t` in my implementation to store this locally? Is there any expectation around the sizes of these fields? If there is no explicit max, what if I implicitly apply one? I'm working on implementing this and I'm trying to figure out how small (byte size) I can make the variables I use to store the values on the connection.",
      "createdAt": "2021-03-02T18:19:48Z",
      "updatedAt": "2021-07-31T01:13:42Z",
      "closedAt": "2021-07-31T01:13:42Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Update Max Ack Delay will be limited by the Max Ack Delay limit once #57 lands.\r\n\r\nThat leaves Packet Tolerance, which I agree is reasonable to limit to a value smaller than 2^62-1 locally.\r\n\r\nWe could add a comment like \"Implementations that have a lower limit than 2^62-1 on the Packet Tolerance MUST set treat it as though the maximum supported Packet Tolerance value has been received.\"",
          "createdAt": "2021-07-22T20:31:57Z",
          "updatedAt": "2021-07-22T20:31:57Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Slight tweak: \"If an endpoint receives a Packet Tolerance value that is larger than the maximum value it can represent, the endpoint MUST use the largest representable maximum value instead.\"",
          "createdAt": "2021-07-22T20:35:51Z",
          "updatedAt": "2021-07-22T20:36:05Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU4MjE1MDU0Mjc=",
      "title": "Use Same Units for min_ack_delay and max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/issues/46",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Do we really need to allow for sub-millisecond min_ack_delays? IMO, it would simplify my code if both min and max had the same units of milliseconds. Just set the value to zero if you really want to allow that small of values and then cap it internally if you receive the frame.\r\n\r\nQuotes from the relevant texts:\r\n\r\n>    max_ack_delay (0x0b):  The maximum acknowledgment delay is an integer\r\n>       value indicating the maximum amount of time in milliseconds by\r\n>       which the endpoint will delay sending acknowledgments.\r\n\r\nand\r\n\r\n>    min_ack_delay (0xff02de1a):  A variable-length integer representing\r\n>       the minimum amount of time in microseconds by which the endpoint\r\n>       can delay an acknowledgement.",
      "createdAt": "2021-03-03T21:35:36Z",
      "updatedAt": "2021-03-08T19:06:18Z",
      "closedAt": "2021-03-08T19:06:18Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think microseconds are better for this draft, since one potential application is within datacenters, where sub-ms timers are not uncommon.\r\n\r\nAt some point, we actually discussed changing the core draft to be microseconds, but concluded that changing the core draft wasn't worthwhile given we already knew we'd have this draft coming with microsecond granularity.",
          "createdAt": "2021-03-04T01:25:58Z",
          "updatedAt": "2021-03-04T01:25:58Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@ianswett at least for Windows, we can't achieve a timer granularity of less than a millisecond with any accuracy, and that only at the cost of changing the default (which can have significant power impacts) from 15.6 milliseconds; so any value less than 1 millisecond is generally unusable for Windows based solutions. I'm not saying we should do something just because that's what Windows can do, but it should be taken into account. How accurately can Linux achieve timers in a data center? Especially if it's on a VM? I'm not going to die on this hill (I already wrote the code) but it's not great code because of these differences.",
          "createdAt": "2021-03-04T01:36:17Z",
          "updatedAt": "2021-03-04T01:36:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "In Linux, high resolution timers are quite common, though certainly not universal, and even VMs running linux guests commonly have hrtimers.\r\n\r\nSpecifically, in Linux TCP pacing and SACK compression(https://lwn.net/Articles/755078/) use hrtimers.",
          "createdAt": "2021-03-04T14:04:56Z",
          "updatedAt": "2021-03-04T15:07:12Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ok. It would have been nice to have max_ack_delay be the same units then. Any idea why milliseconds was decided on for that instead of microseconds? I don't remember any particular discussion around this in the past.",
          "createdAt": "2021-03-08T18:35:27Z",
          "updatedAt": "2021-03-08T18:35:27Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/quicwg/base-drafts/issues/3363",
          "createdAt": "2021-03-08T19:00:45Z",
          "updatedAt": "2021-03-08T19:00:45Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ok. Thanks @ianswett. I'll close this for now then.",
          "createdAt": "2021-03-08T19:06:18Z",
          "updatedAt": "2021-03-08T19:06:18Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU4NTI0NTAwMzU=",
      "title": "CE marking should not always cause an immediate ACK",
      "url": "https://github.com/quicwg/ack-frequency/issues/48",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "From Mirja: \"For ECN, you don't need to send an immediate ACK for each CE. Immediate ACKs are most important when the codepoint switches to CE, but then, if multiple CEs in a row are received, you can bundle the ACK information. See also https://tools.ietf.org/html/draft-ietf-tcpm-accurate-ecn#section-3.2.2.5.1\r\n(Note that we are still working on that section for AccECN but I think any changes are only relevant for specifics of TCP)\"",
      "createdAt": "2021-04-07T14:09:29Z",
      "updatedAt": "2021-10-12T20:39:58Z",
      "closedAt": "2021-10-12T20:39:58Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "From editors' discussion: This text is the same as that in RFC9000 (https://quicwg.org/base-drafts/rfc9000.html#name-sending-ack-frames), and we don't believe we need to depart from existing text for CE-marked packets, since those are true congestion events, and we don't need to optimize for collapsing acks during congestion.",
          "createdAt": "2021-07-22T20:53:59Z",
          "updatedAt": "2021-07-22T20:53:59Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "NONE",
          "body": "Insisting on feeding back an ACK whenever there's a CE will come back to haunt you. \r\n1. After the hundredth CE in a row, you'll probably start to realize that each CE is not a 'congestion event'. \r\n2. You need to make sure that this doesn't force the receiver to ACK every CE-marked ACK, which could lead to interminable ACK ping-pong.\r\n\r\nAdmittedly, the sender should be slowing down, so perhaps it's not so bad to ram the reverse path full of ACKs under 100% congestion in the forward path. But it's not necessary - you could potentially squash other traffic sharing the reverse path. Particularly not nice in the first RTT before the sender starts responding. \r\n\r\nInstead, a requirement like under the [AccECN link](https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn#section-3.2.2.5.1) that Mirja pointed to, where you ACK every 'n' CE marks in a row will be sufficient. And if the peers support ACK frequency control, you might want to say 'n' is the greater of a) whatever 'standard' value is set by the IETF and b) the current ACK frequency requested by the sender.\r\n\r\nFinally, note that the AccECN section linked above was massively changed between -14 (when Mirja pointed to it) and -15 (now). Nearly all of the changes would be relevant to QUIC too (except the stuff about DupACKs, I think). So it's worth reading it all again carefully.",
          "createdAt": "2021-09-11T11:56:08Z",
          "updatedAt": "2021-09-11T11:56:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the specific suggestion Bob, that's extremely helpful.\r\n\r\nI think there are four ways forward:\r\n1) Stick with the current text and deal with the performance hit when using non-classic ECN.\r\n2) Always do something along the lines AccECN is suggesting when ACK_FREQUENCY is negotiated, ie: Ack immediately when max(2, Ack-Eliciting Threshold) packets with CE marks are received.\r\n3) Change the ignore_order 'bool' to be an enum with 4 values that are a mix of Classic(RFC9000) and accurate ECN response to CE marks.\r\n4) Do something completely from RFC9000 or AccECN.  I'm not sure what would inform this, but maybe there are aspects of QUIC which means the ACK response should be different from TCP Accurate ECN.\r\n\r\nI favor 2 and wrote #68 to document that.  My personal opinion is that classic ECN is not able to perform as well as newer marking schemes and should be deprecated, so perpetuating it is actively harmful.",
          "createdAt": "2021-09-11T20:17:19Z",
          "updatedAt": "2021-09-12T13:17:32Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "NONE",
          "body": "The design is not (only) for 'non-classic ECN', it's for handling any severe reverse channel congestion.\r\n\r\nFor the avoidance of doubt, if @ianswett's #2 alternative is meant to be \"as Bob (AccECN) suggested\", a number of possibly important details are missing:\r\n\r\n- a) Immediately ACK the first transition from a non-CE packet to a CE data packet; and b) ACK every max(2, Ack-Eliciting Threshold) contiguous CE marked packets after that.\r\n- The choice of 'packet' (twice) or 'data packet' (once) in the above is deliberate\r\n\r\nI agree that ECN feedback in RFC3168 should be deprecated (which is why I didn't object when it was proposed that AccECN should move from experimental to stds track update to 3168).\r\n\r\n\r\n",
          "createdAt": "2021-09-12T15:46:24Z",
          "updatedAt": "2021-09-12T15:46:24Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR includes the 'Immediately ACK the first transition from non-CE to CE.  PTAL and see if the text looks correct.",
          "createdAt": "2021-09-12T20:55:48Z",
          "updatedAt": "2021-09-12T20:55:48Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "After further thinking, I'm wondering if we should have multiple modes that are indicated by bits in the 'Ignore Order' bytes.\r\n\r\nSpecifically:\r\n- 0 is rfc9000 behavior.\r\n   -  Conveniently, this means clients sending Ignore Order values of 0 or 1 will see no change in behavior.\r\n- 1 is Ignore CE when choosing how frequently to acknowledge packets.\r\n  - This would likely be the best option for ECN algorithms where close to 50% of packets are marked.\r\n- 2 is accurate ECN, which is the current PR.",
          "createdAt": "2021-09-14T00:29:33Z",
          "updatedAt": "2021-09-14T00:29:33Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Following up on my last comment, I created a separate issue (#87) and PR (#88) for the question about whether we want an Ignore ECN bool.",
          "createdAt": "2021-10-10T15:03:33Z",
          "updatedAt": "2021-10-10T15:03:33Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU4NTI4ODI3OTU=",
      "title": "Off-by-one in packet tolerance",
      "url": "https://github.com/quicwg/ack-frequency/issues/49",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "The definition that I use internally is \"the number of packets you can receive without sending an immediate acknowledgment\".  This is different than saying \"please acknowledge every N packets\".\r\n\r\nThe main benefit of this definition is that there are no invalid values for the number.  I recommend making this adjustment in the frame definition: it will be more efficient (by a tiny amount), but it also removes the need to validate the value.",
      "createdAt": "2021-04-07T22:39:24Z",
      "updatedAt": "2021-09-10T00:24:46Z",
      "closedAt": "2021-09-10T00:24:46Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a good change, it's just a matter of writing the text.",
          "createdAt": "2021-07-22T20:35:53Z",
          "updatedAt": "2021-07-22T20:35:53Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU5MjM5Nzg5NDQ=",
      "title": "Asymmetric paths are also impacted by packet rate",
      "url": "https://github.com/quicwg/ack-frequency/issues/51",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It's also true that for many RF media, the performance of the forward path can be impacted by the **rate** of acknowledgment packets when the link bandwidth is shared.\r\n\r\n",
      "createdAt": "2021-06-17T14:16:06Z",
      "updatedAt": "2021-11-10T12:47:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": " \u201cSeverely asymmetric link technologies, such as DOCSIS, LTE, and satellite links, connection throughput in the data direction becomes constrained when the reverse bandwidth is filled by acknowledgment packets. When traversing such links, reducing the number of acknowledgments allows connection throughput to scale much further.\u201d\r\n\r\n- I\u2019m going to push back again on this as largely wrong. Links such as DOCSIS, LTE,  satellite and WiFi are asymmetric. But it\u2019s not just that the design decisions made for these types of link resulted in asymmetric capacity (throughput limit), the designs also share the capacity, and it is important to mitigate the impact on that sharing of capacity, than purely thinking of it items of bytes/sec of capacity used.  A lower feedback rate can help avoid inducing flow starvation to other flows that share resources along the path they use.\r\n\r\n- On mobile devices sending data consumes RF and battery power and is more costly for a host of reasons  not just asymmetry when present.\r\n",
          "createdAt": "2021-09-17T11:22:00Z",
          "updatedAt": "2021-09-17T11:22:00Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@gorryfair -- I don't follow why you say that the statement is wrong. It seems to me that you think that the statement is inadequate. Would you mind responding here with some text you would prefer instead, and I'm happy to wordsmith and turn it into a PR?",
          "createdAt": "2021-10-24T17:03:26Z",
          "updatedAt": "2021-10-24T17:03:26Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I suggest some text something like:\r\n\r\nFor some link technologies (e.g., DOCSIS, LTE, WiFi, and satellite links) transmission of acknowledgment packets contribute to link utilization and can incur  significant forwarding costs. In some cases, the connection throughput in the data direction can become constrained when the reverse bandwidth is filled by acknowledgment packets. In other cases, the rate of acknowledgment packets can impact link efficiency (e.g. transmission opportunities or battery life). A lower ACK frequency can be beneficial when using paths that include such links.\r\n",
          "createdAt": "2021-11-04T15:01:08Z",
          "updatedAt": "2021-11-04T15:01:08Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "@janaiyengar -- Is the text proposal in the issue enough for you to make a PR?",
          "createdAt": "2021-11-10T12:47:37Z",
          "updatedAt": "2021-11-10T12:47:37Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU5Mzg3OTE1MTk=",
      "title": "Could we construct an example of use?",
      "url": "https://github.com/quicwg/ack-frequency/issues/53",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There's a concrete example of one way you can arrange ACKs that has benefit in:\r\nhttps://datatracker.ietf.org/doc/draft-fairhurst-quic-ack-scaling/\r\nThis likely helps in many common scenarios.\r\nWe could make a pull-request based on summarising some of this into an annexe?\r\n",
      "createdAt": "2021-07-07T11:29:09Z",
      "updatedAt": "2021-07-27T15:53:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Gorry -- can you point to the concrete example in the draft? I couldn't find it.\r\n\r\nGenerally, I'd prefer not to spend a lot more text in the draft motivating its value; I think we've got enough in Section 2 already. ",
          "createdAt": "2021-07-22T21:01:04Z",
          "updatedAt": "2021-07-22T21:01:04Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "What I was hoping for was something that unpicks a little how an ACK Ratio of (say) 10 (8 if we prefer, ?) impacts the traffic. I don't see the draft body needing to specify numbers, but I know there is experience by some implementations with this approach, so a short (<1 page) explanation might be good guidance for anyone who has not worked out something better ... but I'd prefer it to be in an annexe, because such things can, and will, change as well as new CCs emerging that can have new requirements, etc.",
          "createdAt": "2021-07-27T15:53:47Z",
          "updatedAt": "2021-07-27T15:53:47Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU5NTM4MzEyNjg=",
      "title": "Response to reordering, what is reordering?",
      "url": "https://github.com/quicwg/ack-frequency/issues/62",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "editorial"
      ],
      "body": "When reviewing the draft I got caught on this part:\r\n\r\nAs specified in Section 13.2.1 of [QUIC-TRANSPORT], endpoints are expected to send an acknowledgement immediately on receiving a reordered ack-eliciting packet. This extension modifies this behavior.\r\n\r\nThere is an issue here in how this draft uses \"reordering\". Section 13.2.1 of RFC 9000 does say that ACKs should be sent immediately if:\r\n\r\n\"In order to assist loss detection at the sender, an endpoint SHOULD generate and send an ACK frame without delay when it receives an ack-eliciting packet either:\r\n\r\n- when the received packet has a packet number less than another ack-eliciting packet that has been received, or\r\n\r\n- when the packet has a packet number larger than the highest-numbered ack-eliciting packet that has been received and there are missing packets between that packet and this packet.\"\r\n\r\nAlthough the first bullet clearly is reordering, the second could be caused by three different mechanisms: Reordering of packets, loss of packets, or sender intentional gap (as discussed in #34)\r\nThus, I think this section needs to be clear if actually means both of the above bullets for when to send ACK or only one of them? \r\n",
      "createdAt": "2021-07-27T12:28:01Z",
      "updatedAt": "2021-10-24T09:17:33Z",
      "closedAt": "2021-10-24T09:17:33Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Magnus, the intent was to follow the RFC9000 definition, so I'll write a PR to clarify that was the intent.",
          "createdAt": "2021-07-27T20:49:50Z",
          "updatedAt": "2021-07-27T20:49:50Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU5OTEwODc4NTc=",
      "title": "Should we add a DELAY_ACK frame?",
      "url": "https://github.com/quicwg/ack-frequency/issues/65",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "As a natural opposite to #34 adding an IMMEDIATE_ACK frame, I want to know if the WG thinks there's sufficient interest in this.  I know there are use cases like WebRTC where fine control over the ACKs is desirable.\r\n\r\n@nibanks may be interested in this, since a similar topic came up on https://github.com/quicwg/datagram/issues/42",
      "createdAt": "2021-09-08T12:32:51Z",
      "updatedAt": "2021-09-16T00:18:54Z",
      "closedAt": "2021-09-16T00:18:54Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I would be fine with using this mechanism to solve the issues described in quicwg/datagram#42.",
          "createdAt": "2021-09-10T12:01:55Z",
          "updatedAt": "2021-09-10T12:01:55Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this would be very useful to have. Specifically we have seen interest similar to what @nibanks has mentioned -- existing applications that have their own \"application layer\" (partial) reliability and congestion control but want to leverage QUIC as a connection-oriented way to send encrypted datagrams. Having more explicit control over not-ACKing would certainly help some of these usecases.\r\n\r\nWhile I would rather people design protocols around QUIC application data semantics in full (streams and DATAGRAMs and some as-yet-undesigned partial reliability feature) rather than just plumbing an existing protocol over QUIC DATAGRAMs, I think that having a facility to get more applications running over QUIC is very useful.",
          "createdAt": "2021-09-10T17:13:13Z",
          "updatedAt": "2021-09-10T17:13:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Just say NO! Really, this kind of experiment goes in the way of progressing the delayed ACK proper. We have tons of experience with delayed acks, and we understand exactly what it does. Why would we create this additional mechanism, with unproven effects?",
          "createdAt": "2021-09-13T00:20:40Z",
          "updatedAt": "2021-09-13T00:20:40Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "So, I think this naturally leads to the question of how long an ACK delay is actually acceptable for coexistence with other Internet use. Delayed ACKs our tens of packets are likely OK.  I'll argue that \"infinite\" delay (No ACK) it is not a great place to dig into. I suggest we should instead be restricting this to a few RTTs... (10's? 100s of packets).   I'd argue that for some form of reactive congestion control, feedback at least every few RTTs is necessary - this could even be a form of slower-reacting circuit-breaker, with the upper layers formally providing the responsive control to incipient ingestion.\r\n",
          "createdAt": "2021-09-13T11:22:55Z",
          "updatedAt": "2021-09-13T11:22:55Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I'm in agreement with @mjoras that a change like this would better be aligned with the application data semantics, unreliable datagrams in this case. As I indicated in https://github.com/quicwg/datagram/issues/42#issuecomment-912513452, there are several reasons an application protocol would want a reduction in (not complete elimination of) generated ACKs when using unreliable datagrams. There might be additional uses, generally, for delaying ACKs, but the reasoning around it is more complicated for reliable data. For the unreliable support, I can write that up in a new extension draft (if that is the general WG consensus).",
          "createdAt": "2021-09-13T12:16:00Z",
          "updatedAt": "2021-09-13T12:16:00Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The idea of this extending the ACK timeout, but not removing it completely is interesting.\r\n\r\nAn alternative design would be a DELAY_ACK frame which ensured a packet doesn't elicit an immediate ACK, but would still arm the timer for the delayed ACK alarm.",
          "createdAt": "2021-09-13T13:31:24Z",
          "updatedAt": "2021-09-13T13:31:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Given the swathe of needs and possible options, I currently think there's going to need to be some more exploration of this space with some more substantial write ups.",
          "createdAt": "2021-09-13T13:47:17Z",
          "updatedAt": "2021-09-13T13:47:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just say NO! Really, this kind of experiment goes in the way of progressing the delayed ACK proper. We have tons of experience with delayed acks, and we understand exactly what it does. Why would we create this additional mechanism, with unproven effects?\r\n\r\nWe already have this ACK issue with PADDING only packets, which count towards bytes in flight, but are not ack-eliciting.  That design choice always terrified me.  I would have been much more comfortable with something like the DELAY_ACK design I proposed just above, which would ensure you eventually get an ACK for in-flight packets.",
          "createdAt": "2021-09-13T13:52:40Z",
          "updatedAt": "2021-09-13T13:52:58Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "As a mechanism, we should not use a frame to signal how a different frame should be interpreted. QUIC's design generally assumes that a sender does not control how frames are packetized, and this runs afoul of that unstated assumption.\r\n\r\nSpecifying the mechanism is easy, but I don't think this is quite as straightforward to reason about, at least in the context of the ack frequency draft. Broadly, this is not about controlling ack frequency, it's about disabling acks, or partially disabling acks, which makes it harder to reason about.\r\n\r\nLet's not do this here; as @LPardue notes, this has to become a larger conversation.",
          "createdAt": "2021-09-13T18:55:55Z",
          "updatedAt": "2021-09-13T18:55:55Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Given the pushback against my initial attempt, I'm pivoting to the DELAY_ACK frame.\r\n\r\nI'd actually like the negotiation of this extension to indicate the delayed ack behavior applies to PADDING only and PADDING+ACK packets as well, since I think those can be a bit of a footgun, but I'd like to see what people think of the DELAY_ACK frame before writing that text.",
          "createdAt": "2021-09-14T00:39:06Z",
          "updatedAt": "2021-09-14T00:39:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@janaiyengar \r\n> As a mechanism, we should not use a frame to signal how a different frame should be interpreted. QUIC's design generally assumes that a sender does not control how frames are packetized, and this runs afoul of that unstated assumption.\r\n\r\nI'm not sure if I agree. Yes, I agree with the statement that a frame should not affect how other frames are interpreted.\r\n\r\nBut we can think of DELAY_ACK frame as a frame that affects how a *packet* is processed. Assuming that we adopt IMMEDIATE_ACK, we'd have a precedent for having such a thing. Essentially, IMMEDIATE_ACK is a flag of a packet that happens to be sent as a frame. If we think that way, defining a DELAY_ACK frame (or a THIS_PACKET_IS_NOT_ACK_ELICITING frame) as makes perfect sense IMO.",
          "createdAt": "2021-09-14T02:51:16Z",
          "updatedAt": "2021-09-14T02:51:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@ianswett I really think this belongs in a separate draft, and mostly a separate negotiation. It should be possible to negotiate delayed acks without also negotiating ack suppression.",
          "createdAt": "2021-09-14T02:59:22Z",
          "updatedAt": "2021-09-14T02:59:22Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I've been convinced this belongs in a separate draft, and that there may be more that goes into that draft to enable the various related use cases.\r\n\r\nI'll leave this open for now, but likely close it and the PR in the not so distant future.",
          "createdAt": "2021-09-14T17:32:48Z",
          "updatedAt": "2021-09-14T17:32:48Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing with no action, I think this is the wrong draft.",
          "createdAt": "2021-09-16T00:18:54Z",
          "updatedAt": "2021-09-16T00:18:54Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU5OTEyODc3NDY=",
      "title": "Change diagrams to use the notation in QUIC transport",
      "url": "https://github.com/quicwg/ack-frequency/issues/66",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "editorial"
      ],
      "body": "They currently use ascii art.\r\n\r\nWill write this up once #64 is merged.",
      "createdAt": "2021-09-08T15:50:00Z",
      "updatedAt": "2021-09-17T21:08:54Z",
      "closedAt": "2021-09-17T21:08:54Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "sgtm, thanks!",
          "createdAt": "2021-09-08T16:10:33Z",
          "updatedAt": "2021-09-08T16:10:33Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDODddxTs47juPn",
      "title": "Can we explain the motivation for Immediate ACK?",
      "url": "https://github.com/quicwg/ack-frequency/issues/70",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There's nothing odd about an immediate ACK! Perhaps the text should start by saying that the spec allows a receiver to do this anyway?\r\n\r\nHowever, the current text doesn't explain why the Immediate ACK might be useful.\r\n\r\nI could see three places that might benefit from an IMMEDIATE_ACK:\r\n\r\nTwo cases relevant to SCTP [RFC7053] are: When the rate of transmission was very low and packets might be lost and not detected (something not uncommon in some SCTP uses); as an alternative to detect connectivity failure and trigger path failover. I'm not sure how important these specific cases are for QUIC, because the discussion at the time in TSVWG appeared to centre around use for signalling traffic?\r\n\r\nThere could also be real opportunity to use this to get more precise timing/congestion information. A set of per-packet ACKs might be useful while a CC is probing to confirm available capacity, etc.\r\n\r\nHave I missed a killer application for the method - it would be helpful to me to understand /some example for how the WG think this could be used. \r\n\r\n(aside: I am actually uncertain whether this would really be a good change to TCP, especially with the heterogeniety of TCP middleboxes and senders,... that's another story, but I'd think it might be nice to not rely on draft-gomez-tcpm-ack-pull as a reference. I could suggest RFC7053, where people might recall there was quite some discussion in TSVWG about whether SCTP would benefit from being able to trigger an immediate response.)\r\n\r\n",
      "createdAt": "2021-09-17T10:55:09Z",
      "updatedAt": "2021-10-25T17:37:45Z",
      "closedAt": "2021-10-25T17:37:45Z",
      "comments": [
        {
          "author": "evolodina",
          "authorAssociation": "NONE",
          "body": "We use an immediate ACK to support CC by delayed ACKs. ",
          "createdAt": "2021-09-17T11:44:30Z",
          "updatedAt": "2021-09-17T11:44:30Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/quicwg/ack-frequency/pull/95 adds two use cases that uses IMMEDIATE_ACK.",
          "createdAt": "2021-10-21T13:10:15Z",
          "updatedAt": "2021-10-21T13:10:15Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDODddxTs47j0nV",
      "title": "Undesirable consequences seems over stated for small changes",
      "url": "https://github.com/quicwg/ack-frequency/issues/71",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "\u201cAs discussed in Section 9 however, there are undesirable consequences to congestion control and loss recovery if a receiver uniltaerally reduces the acknowledgment frequency.\u201c\r\n\r\n- This is a harsh statement. I don\u2019t think it is true for smaller changes. There is much experience of using TCP where stretch ACKs cover more than two packets. This is a matter of scale. For instance: I\u2019m confident that stretched TCP ACKs covering 4 segments (maybe more ... I\u2019d love to say up to IW) would not break TCP CC, so I don\u2019t see why the editors want to suggest it could break QUIC CC! This really does need a less obfuscated explanation. \r\n",
      "createdAt": "2021-09-17T11:25:38Z",
      "updatedAt": "2021-10-12T18:59:04Z",
      "closedAt": "2021-10-12T18:59:04Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd be happy to reword this to \"there can be undesirable consequences ...\", but were you looking for a larger change?",
          "createdAt": "2021-09-18T08:23:23Z",
          "updatedAt": "2021-09-18T08:23:23Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Thanks - yes, /can be/ would seem fair, since they are enumerated later.",
          "createdAt": "2021-09-20T08:15:04Z",
          "updatedAt": "2021-09-20T08:15:16Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDODddxTs47j0t4",
      "title": "Delaying detection of loss is a serious CC problem",
      "url": "https://github.com/quicwg/ack-frequency/issues/72",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [
        "janaiyengar"
      ],
      "labels": [
        "design",
        "needs-pr"
      ],
      "body": "Section 9.1 - There are CC considerations with respect to how long it is reasonable for a flow to hold-off detecting congestion and responding. This needs to be discussed.\r\n\r\nWhen an endpoint detects persistent congestion, it MUST promptly reduce the rate of transmission when it receive or detects an indication of congestion (e.g., loss or ECN marking) [RFC2914], the Ignore Order value of true (0x01) in this ID allows a sender to extend that period, postponing detection of loss. That might be reasonable, but excessive delay can be dangerous - and therefore the impact really needs to be discussed: delaying a fraction of a RTT is in my mind safe, intentionally delaying by an RTT is arguable. A delay of many RTTs is endangers other flows, and we need to at least say that in some way ([RFC8084] took an alternate view of how long might be safe).\r\n",
      "createdAt": "2021-09-17T11:26:11Z",
      "updatedAt": "2021-10-25T17:40:55Z",
      "closedAt": "2021-10-25T17:40:55Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "See PR #75 ",
          "createdAt": "2021-09-20T15:00:23Z",
          "updatedAt": "2021-09-20T15:00:23Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this warrants a note about how a sender SHOULD NOT use a delay that is larger than an RTT unless the sender has other information about either the network or current network conditions. Otherwise, the receiver does not need to enforce anything here.",
          "createdAt": "2021-10-12T21:09:21Z",
          "updatedAt": "2021-10-12T21:10:01Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@janaiyengar \r\n> I think this warrants a note about how a sender SHOULD NOT use a delay that is larger than an RTT unless the sender has other information about either the network or current network conditions.\r\n\r\nDelay of loss detection has negative impact on loss recovery as well. Considering that the time threshold defined in RFC 9002 is 9/8 RTT, I might ague that, when Ignore Order is set to true, then the maximum delay being advertised SHOULD be no greater than 9/8 RTT.\r\n\r\nThese values provide responsiveness comparable to Rack when a packet is lost - the loss would be detected within 5/4 RTT.\r\n\r\n~~Separately, it might be worth pointing out that the time threshold has to be tuned when the sender sets Ignore Order bit~~ (stuck out, as this point is already covered by Section 8).",
          "createdAt": "2021-10-15T00:31:04Z",
          "updatedAt": "2021-10-15T00:35:01Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDODddxTs47j0z6",
      "title": "Section 9.3 - Isn\u2019t ACK Clocking different to the CC?",
      "url": "https://github.com/quicwg/ack-frequency/issues/73",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "To me, ACK Clocking is a separate point that applies to any type of CC when the cwnd limits the sender.\r\n\r\nI agree there could be a concern is around whether a less frequent ACK policy can induce a cwnd-limited sender to send bursts of packets that could induce loss or disrupt sharing of the path with other flows. The QUIC specification already permits an initial window of 10 packets, and motivates the need for pacing. I think it is important this text refers to the QUIC transport section on pacing to mitigate bursts.\r\n",
      "createdAt": "2021-09-17T11:26:43Z",
      "updatedAt": "2021-10-25T17:40:56Z",
      "closedAt": "2021-10-25T17:40:55Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Better worded perhaps in PR #75.\r\n",
          "createdAt": "2021-09-20T15:00:03Z",
          "updatedAt": "2021-10-12T21:19:47Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDODddxTs47j1eB",
      "title": "Impact of Delayed ACKs on CC growth",
      "url": "https://github.com/quicwg/ack-frequency/issues/74",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In 9.3. Window-based Congestion Controllers\r\n\r\nI thought that unless there is loss reported, a QUIC ACK Frame releases sending window. In a similar manner as the accurate byte counting style in TCP, a QUIC sender solely operates on the basis of bytes acked, not the number of ACK frames received. \r\n\r\nSo while a delayed ACK could delay a round of growth when the ACK Ratio is larger, it is only delayed by the time to ACK the set of received packets. In looking at various QUIC CC over medium and longer path RTTs this effect was quite small, and the default ACK delay was not unreasonable; for shorter path RTTs this might be different\r\n",
      "createdAt": "2021-09-17T11:30:01Z",
      "updatedAt": "2021-10-25T17:40:56Z",
      "closedAt": "2021-10-25T17:40:56Z",
      "comments": [
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "See PR #75 ",
          "createdAt": "2021-09-20T14:59:32Z",
          "updatedAt": "2021-09-20T14:59:32Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDODddxTs48a2d7",
      "title": "Editorial: Ignore Order explanation",
      "url": "https://github.com/quicwg/ack-frequency/issues/76",
      "state": "CLOSED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Section 4 explains what all the fields are mean first and then explains the exception cases.  It seems like this was done the opposite way for Ignore order.\r\n\r\nI propose we change the current text:\r\n> An 8-bit field representing a boolean truth value. This field MUST have the value 0x00 (representing false) or 0x01 (representing true). This field can be set to true by an endpoint that does not wish to receive an immediate acknowledgement when the peer observes reordering (Section 7.1). Receipt of any other value MUST be treated as a connection error of type FRAME_ENCODING_ERROR.\r\n\r\nTo:\r\n> An 8-bit field representing a boolean truth value. This field can be set to true by an endpoint that does not wish to receive an immediate acknowledgement when the peer observes reordering (Section 7.1).  The value of this field MUST be 0x00 (representing false) or 0x01 (representing true). Receipt of any other value MUST be treated as a connection error of type FRAME_ENCODING_ERROR.\r\n",
      "createdAt": "2021-10-01T19:02:05Z",
      "updatedAt": "2021-10-09T22:53:25Z",
      "closedAt": "2021-10-09T22:53:25Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM, want to send me a PR or should I?",
          "createdAt": "2021-10-01T20:08:01Z",
          "updatedAt": "2021-10-01T20:08:01Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDODddxTs48bfGz",
      "title": "Migration and ACK frequency",
      "url": "https://github.com/quicwg/ack-frequency/issues/79",
      "state": "CLOSED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "The draft doesn't mention anything about ACK frequency and connection migration.  What should we do, for example, when a client has migrated and now sends a PING to force the server to use a new path?  Should it send PING+IMMEDIATE_ACK?",
      "createdAt": "2021-10-01T23:30:22Z",
      "updatedAt": "2021-10-21T13:11:05Z",
      "closedAt": "2021-10-21T13:11:05Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems sensible.  Mind writing a PR?",
          "createdAt": "2021-10-06T19:28:16Z",
          "updatedAt": "2021-10-06T19:28:16Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDODddxTs48iPnz",
      "title": "Guidance on min_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/issues/80",
      "state": "CLOSED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Although I understand what min_ack_delay represents it's not clear to me what an implementation should do with that value. Is the purpose to make sure that stacks sufficiently wait enough time before triggering PTO?  There's no guidance on this in the draft.  Perhaps there should be.",
      "createdAt": "2021-10-04T20:36:15Z",
      "updatedAt": "2021-10-21T14:01:23Z",
      "closedAt": "2021-10-21T14:01:23Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "`min_ack_delay` represents the minimum time that the receiver can delay for. In the common case, this would be the receiver's clock or timer granularity. This is for the receiver to indicate that the sender cannot reduce `max_ack_delay` below this value. So a receiver implementation can simply use its granularity for this value, and a sender must ensure that its `max_ack_delay` is not below the received `min_ack_delay`.\r\n\r\nDoes this help, @rpaulo? We can add some text to clarify this.",
          "createdAt": "2021-10-12T22:49:48Z",
          "updatedAt": "2021-10-12T22:49:48Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks. Yes, I think this should be explained in the draft like you said. ",
          "createdAt": "2021-10-12T23:01:55Z",
          "updatedAt": "2021-10-12T23:01:55Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDODddxTs48mMN4",
      "title": "Requested Max Ack Delay in microseconds",
      "url": "https://github.com/quicwg/ack-frequency/issues/84",
      "state": "CLOSED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm surprised that Requested Max Ack Delay is in microseconds.  I was really expecting it to the be same unit as what's in the Transport Parameter. Of course, this allows max_ack_delay to be really short (< 1ms).  Since we now have IMMEDIATE_ACK, is this really necessary?  It would simplify the specification (and perhaps it would prevent certain bugs) if the unit of requested max ack delay was the same as max ack delay.",
      "createdAt": "2021-10-05T18:20:59Z",
      "updatedAt": "2021-10-05T19:18:23Z",
      "closedAt": "2021-10-05T19:18:23Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "See https://github.com/quicwg/ack-frequency/issues/46?",
          "createdAt": "2021-10-05T18:23:29Z",
          "updatedAt": "2021-10-05T18:23:29Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand the reasoning and I was okay doing it for min_ack_delay, but is that necessary for max_ack_delay as well?",
          "createdAt": "2021-10-05T18:36:54Z",
          "updatedAt": "2021-10-05T18:36:54Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's preferable to keep both in us.  Datacenters have extremely low latency that are typically sub-us, so there's no reason to limit ourselves here.  Is there a problem this is causing for you?",
          "createdAt": "2021-10-05T18:48:45Z",
          "updatedAt": "2021-10-05T18:48:45Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No problems, just POLA.",
          "createdAt": "2021-10-05T19:14:40Z",
          "updatedAt": "2021-10-05T19:14:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Given I think this has already been discussed, I'm going to close this.",
          "createdAt": "2021-10-05T19:18:23Z",
          "updatedAt": "2021-10-05T19:18:23Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDODddxTs48w-dl",
      "title": "Ack-eliciting threshold needs more clarity",
      "url": "https://github.com/quicwg/ack-frequency/issues/85",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While reading the latest ack-frequency draft, I am confused with the wording that was added in https://github.com/quicwg/ack-frequency/pull/58\r\n`Ack-Eliciting Threshold: A variable-length integer representing the maximum number of ack-eliciting packets the recipient of this frame can receive before sending an immediate acknowledgment. A value of 0 will result in an immediate acknowledgement whenever an ack-eliciting packet received.`\r\n\r\nIf I have ack-eliciting threshold = 1, to me it means that I can receive 1 ack-eliciting packet before sending an ACK, i.e. I have to send ACK after receiving 1 packet. But looking at the example of 0, this interpretation looks wrong.\r\n\r\n@martinthomson suggested, maybe the \"before\" needs to be \"without\" and an additional sentence added: \"An immediate acknowledgement is sent when more than this number of packets have been received.\"\r\n\r\nI agree with his suggestion.",
      "createdAt": "2021-10-06T23:57:41Z",
      "updatedAt": "2021-10-12T10:57:34Z",
      "closedAt": "2021-10-12T10:57:34Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the issues, this is a bit unclear.  PTAL at #86 ",
          "createdAt": "2021-10-10T14:06:12Z",
          "updatedAt": "2021-10-10T14:06:12Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDODddxTs486oPg",
      "title": "Add an 'Ignore CE' bit in addition to Ignore Order",
      "url": "https://github.com/quicwg/ack-frequency/issues/87",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "When thinking about #48, it occurred to me that there may be use cases for not changing the acknowledgement behavior in the face of ECN.\r\n\r\nThe most obvious example is an ECN scheme where the bit means faster/slower, and so at equilibrium, every other packet should be marked.  This type of marking would trigger the most pathological ACK behavior of either the current draft(ie: RFC9000) or #68.",
      "createdAt": "2021-10-10T14:39:49Z",
      "updatedAt": "2021-10-21T13:20:55Z",
      "closedAt": "2021-10-21T13:20:55Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This seems like a good way to manage acknowledgment behaviour when different ECN schemes are in use.  It's not necessarily a complete solution, but it should help avoid the worst sorts of reactions.",
          "createdAt": "2021-10-12T22:27:49Z",
          "updatedAt": "2021-10-12T22:27:49Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "How to send an ACK on CE marking can be a receiver side logic, one ACK when CE marking changes. I agree if every other packet is marked, then that triggers every other ACK, but I don't understand why this would happen in steady state.\r\n\r\nWould be good to know a use-case for this. Are there networks that are marking CE incorrectly - for that we should disable ECN as described in RFC 9000.\r\n\r\nThis has similar implications as `Ignore-order` where the delayed CE marks will result in delayed response to congestion at the sender and hence the network queuing will continue to increase possibly causing more CE marks on other responsive flows (that don't have ignore-ecn set to true) and will cause unfairness.",
          "createdAt": "2021-10-13T05:31:04Z",
          "updatedAt": "2021-10-13T05:31:04Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I had this Netdev conference presentation and paper in mind by Hari Balakrishnan of MIT:\r\nhttps://legacy.netdevconf.info/0x12/session.html?congestion-control-for-cellular-wireless-networks\r\n\r\nIt's research, but it's a sensible algorithm in certain environments like cell networks.",
          "createdAt": "2021-10-13T09:56:32Z",
          "updatedAt": "2021-10-13T09:56:32Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Thank you @ianswett for providing the link. I watched the video of the talk and it doesn't seem like he is using ECN along with Accelerate and Brake. One can simply disable ECN if they don't wish to use that method in the data packets.\r\n\r\nDisabling of ECN can also happen in the middle of the connection. I don't think we need to say, Sender wants to use ECN but he doesn't want to get immediate ACKs when CE marks are received at the receiver - that sounds contradictory to me.",
          "createdAt": "2021-10-15T04:56:49Z",
          "updatedAt": "2021-10-15T04:57:14Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "@ianswett your comment https://github.com/quicwg/ack-frequency/issues/48#issuecomment-917708790 seems like a good choice to me. ACK immediately whenever there is transition.",
          "createdAt": "2021-10-15T04:58:40Z",
          "updatedAt": "2021-10-15T04:58:50Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Most endpoints ignore ECN today, so I don't see how this is more harmful than the status quo?\r\n\r\nSome endpoints negotiate ECN and then ignore it as well.\r\n\r\nWith Hari's scheme, the Ignore CE option is exactly what you'd want, because a transition from non-CE to CE happens so frequently.",
          "createdAt": "2021-10-15T09:51:17Z",
          "updatedAt": "2021-10-15T09:51:17Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "How the stacks ignore today would make the other side disable ECN even if it was negotiated successfully. Meaning, the sender will start sending Non-ECT in its packets and the routers will drop instead of marking CE.\r\n\r\nBut if the sender continues to send packets with ECT(0) or ECT(1) after sending ignore-ECN = true, that means this sender is greedy as it doesn't want its packets to be dropped at the bottleneck and also, it doesn't want to respond the congestion marks right away.\r\n\r\nFor senders using classic ECN, this is OK only when the ACKs eventually come within 1RTT ballpark as classic congestion controllers reduce cwnd once per RTT. But, for L4S scalable congestion control, this isn't good enough as the ACK with CE feedback should come immediately (with respect to time). Multiple packets with CE marks can be bundled into one ACK - which is the ACK on transition from CE to non-CE method.",
          "createdAt": "2021-10-19T00:40:32Z",
          "updatedAt": "2021-10-19T06:29:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There are many scenarios to use ECN, and today the most valuable one is the datacenter, not the public internet.  In a datacenter, this may be an optimal ACK-ing scheme.\r\n\r\nIn terms of classic vs L4S, it seems like both have delays which would be fairly tolerable (ie: 1 RTT and 1/8 or 1/4 RTT depending upon one's loss threshold), but larger delays could reduce their responsiveness to congestion.\r\n\r\nThis is similar to Ignore Order, since both are signals which may indicate congestion, so the same guidance could apply to both to ensure sufficiently fast feedback in the case of possible loss or ECN marking.",
          "createdAt": "2021-10-19T19:11:52Z",
          "updatedAt": "2021-10-19T19:11:52Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "> This is similar to Ignore Order, since both are signals which may indicate congestion, so the same guidance could apply to both to ensure sufficiently fast feedback in the case of possible loss or ECN marking.\r\n\r\nYes, they are the same with regards to delayed response to congestion and we are discussing that at https://github.com/quicwg/ack-frequency/issues/93. One subtle difference between the two is that in case of ECN, the packets are never dropped which could cause slightly more unfairness to other flows. \r\n\r\nSimilar to #93, we can add a limit to Max Ack Delay when ignore-ecn is used.",
          "createdAt": "2021-10-20T05:06:02Z",
          "updatedAt": "2021-10-20T05:06:02Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Even middleboxes which mark ECN also drop packets, they just mark earlier than they drop.  I'm not aware of devices which when ECN is negotiated, actually don't drop packets and instead rely entirely on ECN.  This seems like a recipe for unfairness, so I can't imagine someone doing this\r\n\r\nIf you have evidence this really exists in the wild, that'd be interesting, but I think it's a fundamentally unfair design choice.",
          "createdAt": "2021-10-20T12:53:53Z",
          "updatedAt": "2021-10-20T12:53:53Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Classic ECN RFC 3168 says,\r\n`First, ECN-Capable routers will only mark packets (as opposed to\r\n   dropping them) when the packet marking rate is reasonably low. During\r\n   periods where the average queue size exceeds an upper threshold, and\r\n   therefore the potential packet marking rate would be high, our\r\n   recommendation is that routers drop packets rather then set the CE\r\n   codepoint in packet headers.`\r\n\r\nFor low to medium congestion, the middle box will mark CE without dropping and only after high congestion which could imply non-compliance from sender, it will revert to dropping packets. So, there is some degree of unfairness when congestion starts to build up. \r\n\r\nThe use of ECN in public Internet is to avoid queue buildup and we would be going against that if we use ECN (to avoid packet drops) but don't respond in timely manner. If the only use case of this is data centers (of which I have very limited knowledge), then should we mention that in the draft? Something like, `this option SHOULD NOT be used on public Internet.`?",
          "createdAt": "2021-10-21T07:59:08Z",
          "updatedAt": "2021-10-21T07:59:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "My view is that implementations largely do not conform to 3168, so even though the text says that, I'd only believe it if someone could show me evidence that is what happens in the wild.\r\n\r\nAlso, I think we should permanently deprecate 3168 and take back the bit, but that's a different conversation.",
          "createdAt": "2021-10-21T12:38:53Z",
          "updatedAt": "2021-10-21T12:38:53Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDODddxTs487JxU",
      "title": "Maximum value for ack-eliciting threshold",
      "url": "https://github.com/quicwg/ack-frequency/issues/89",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [
        "janaiyengar"
      ],
      "labels": [
        "design"
      ],
      "body": "In #86, I noted that the text around a maximum value is a little squishy.  It says: \r\n\r\n> If an endpoint receives an ACK-Eliciting Threshold value that is larger than the maximum value it can represent, the endpoint MUST use the largest representable value instead.\r\n\r\nThe problem here is not about representing values.  We have to assume that 62-bit values can be represented easily by anything that can do QUIC.  The real problem is that there is a value beyond which performance tanks badly.  Endpoints might want to set a limit for this to prevent that from happening.  Why not instead just say that endpoints can set a limit for this threshold?\r\n\r\nThat means that we might need to provide some advice around setting the limit.  For instance, maybe we might suggest that a value that exceeds the current congestion window (measured in MTUs) might be too high.\r\n\r\n",
      "createdAt": "2021-10-11T00:36:15Z",
      "updatedAt": "2021-10-25T11:12:49Z",
      "closedAt": "2021-10-25T11:12:49Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The receiver doesn't know the peer's congestion window, so that might be tricky.\r\n\r\nIf there's a value beyond which performance tanks, isn't that an error on the part of the sender of the ACK_FREQUENCY frame?  I agree one could use this frame to degrade performance, but the sender could also just set a max CWND of 1 to degrade performance, which would be a lit simpler.",
          "createdAt": "2021-10-11T11:50:23Z",
          "updatedAt": "2021-10-11T11:50:23Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that providing advice on setting a limit is tricky and there are other ways to destroy performance.  The worst case is actually when both the threshold and the max ack delay are unreasonably large.",
          "createdAt": "2021-10-11T18:24:31Z",
          "updatedAt": "2021-10-11T18:24:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We could bound the delay to the SRTT as measured locally.  It's not guaranteed to be the same value the sender measures, but it could be close enough to mitigate large issues.  That being said, I am still unsure if this is a problem worth solving, given the sender should have a strong incentive to specify good values.",
          "createdAt": "2021-10-11T20:19:16Z",
          "updatedAt": "2021-10-11T20:19:16Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I'm ambivalent regarding whether we provide advice on limits.  We might try to capture some of this general advice.  Or not.\r\n\r\nI'm mostly concerned that we remove this pointless clause.",
          "createdAt": "2021-10-12T00:15:57Z",
          "updatedAt": "2021-10-12T00:15:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "That's there for a specific reason.  If you store the threshold as a uint_8, and the peer sends you something larger we want clear and consistent guidance on what to do with it(ie: set the value to 255).\r\n\r\nIf that's unclear, editorial suggestions are welcome.",
          "createdAt": "2021-10-12T10:48:21Z",
          "updatedAt": "2021-10-12T10:48:21Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, when I read this the first time, the thought that an implementation would limit the value to 8 or 16 bit came immediately to mind, like @ianswett describes.",
          "createdAt": "2021-10-12T18:38:12Z",
          "updatedAt": "2021-10-12T18:38:12Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "This text **is** about choice of internal representation at the receiver. I do not recall what caused this to get added, but as I think about this more now, I am sympathetic to a part of @martinthomson's point of view. However, this isn't about performance (as @ianswett notes) -- we don't want the receiver second guessing the sender's intent.\r\n\r\nSo the text currently says that a receiver can choose to limit the size of this threshold. However, we provide no guidance as to why a receiver might choose a lower value, leaving this question open to implementations. I think we have two choices:\r\n1. the text should be clear about the tradeoffs and how a receiver might make this choice, or\r\n2. simply not say anything here, with the expectation that receivers ought to respect the sender's request (use uint64).\r\n\r\nIn the spirit of the rest of this draft, I propose that:\r\n- we follow (2), and\r\n- if there is a compelling reason to allow a receiver to use something smaller, introduce text to say that the receiver \"SHOULD respect sender's request\" and explain the compelling exceptional case.\r\n\r\nDo we have a compelling exception?",
          "createdAt": "2021-10-12T23:02:38Z",
          "updatedAt": "2021-10-12T23:02:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I think that (2) alone is fine.\r\n\r\nI don't have a compelling exception.  Note that we also have a time limit.  This value might be deliberately set high in order to engage the timer rather than the counter.  BOTH might be set ridiculously high, in which case the connection might then faceplant spectacularly, but we don't have to make the protocol completely foolproof.",
          "createdAt": "2021-10-13T00:44:25Z",
          "updatedAt": "2021-10-13T00:44:25Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The original issue was #45.  Microsoft is using a uint8_t for this field, not a uint64, so they can't represent the full value.\r\n\r\nWe can remove the sentence and assume implementations will do the right thing, but we can't assume everyone will use a uint64.",
          "createdAt": "2021-10-21T13:39:00Z",
          "updatedAt": "2021-10-21T13:39:00Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the main trouble here is with the normative MUST when an endpoint chooses to go off-spec. As @ianswett noted, we folks do want to use a < 64-bit value, so it might still be useful to note something here. So here's what I propose:\r\n\r\n\"An endpoint might use a local representation for this value that is smaller than 64 bits for optimization purposes. If it does so, and if it receives an ACK-Eliciting Threshold value that is larger than the maximum value it can represent locally, the endpoint can use the largest representable value instead.\"",
          "createdAt": "2021-10-21T13:52:36Z",
          "updatedAt": "2021-10-21T13:52:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I would prefer that people go off-spec rather than make allowances like this in the spec.  Honestly though, msquic is probably safe with clamping to 255 maximum.  No one can say they aren't compliant if they acknowledge earlier.",
          "createdAt": "2021-10-21T15:36:29Z",
          "updatedAt": "2021-10-21T15:36:29Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with leaving the text out. I am sympathetic to @martinthomson's view, despite the fact that we've had this text in the spec. I'm ok with removing it.\r\n\r\n@ianswett @nibanks -- thoughts?",
          "createdAt": "2021-10-24T09:19:16Z",
          "updatedAt": "2021-10-24T09:19:16Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I added this text to address @nibanks issue, so I'll let him decide.",
          "createdAt": "2021-10-24T11:30:35Z",
          "updatedAt": "2021-10-24T11:30:35Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I don't care enough to die on this hill, but I do think it's better to have text indicating the peer might have limits and acknowledge earlier as a result, than to have to text at all. ",
          "createdAt": "2021-10-24T12:19:21Z",
          "updatedAt": "2021-10-24T12:19:21Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, I've reworded to simply say that a receiver can ack earlier. PTAL @martinthomson @nibanks @kazuho @ianswett",
          "createdAt": "2021-10-24T16:34:23Z",
          "updatedAt": "2021-10-24T16:34:23Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "I_kwDODddxTs48-Zcz",
      "title": "Commit 8a87dbd3d38c40507a2ca346f242fbdee3866ec3 was lost in the merge",
      "url": "https://github.com/quicwg/ack-frequency/issues/90",
      "state": "CLOSED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Commit 8a87dbd3d38c40507a2ca346f242fbdee3866ec3 seem to have been lost with the rename.",
      "createdAt": "2021-10-11T18:15:58Z",
      "updatedAt": "2021-10-25T16:49:41Z",
      "closedAt": "2021-10-25T16:49:40Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/quicwg/ack-frequency/pull/91",
          "createdAt": "2021-10-12T03:19:19Z",
          "updatedAt": "2021-10-12T03:19:19Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "It was intentionally removed, see https://github.com/quicwg/ack-frequency/pull/57/files",
          "createdAt": "2021-10-12T09:56:56Z",
          "updatedAt": "2021-10-12T09:56:56Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What happened to this sentence?\r\n> Any value larger than 16,383,000 microseconds is\r\n>   invalid, as specified for the `max_ack_delay` transport parameter. ",
          "createdAt": "2021-10-12T18:35:22Z",
          "updatedAt": "2021-10-12T18:35:40Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@rpaulo -- that number is unnecessary, since the real cap is the advertised `max_ack_delay`, which has its limit specified. As to why the endpoint is required to have `min_ack_delay <= max_ack_delay`, an endpoint cannot advertise a min that is larger than its max.",
          "createdAt": "2021-10-12T23:30:00Z",
          "updatedAt": "2021-10-12T23:30:00Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I must be missing something then. I\u2019m not debating min_ack_delay at all. The paragraph I quoted is discussing max_ack_delay. ",
          "createdAt": "2021-10-12T23:51:45Z",
          "updatedAt": "2021-10-12T23:51:45Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "The point I was making is that the real cap is the advertised `max_ack_delay`. Instead of having the cap of `max_ack_delay` in two different places (here and in RFC 9000), it's better to have it in one place.",
          "createdAt": "2021-10-21T13:19:57Z",
          "updatedAt": "2021-10-21T13:19:57Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@rpaulo -- are you ok with closing this issue, or would you like some change?",
          "createdAt": "2021-10-24T16:25:54Z",
          "updatedAt": "2021-10-24T16:25:54Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@janaiyengar I still would like a change to be made.  Let's discuss on Slack since we're out of sync here.",
          "createdAt": "2021-10-24T16:29:22Z",
          "updatedAt": "2021-10-24T16:29:22Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Sharing what @rpaulo and I agreed on: The text currently calls out the units difference and I don\u2019t think we need to restate the number here just because the units are different. Repeating the number in different places can lead to confusion later if the number changes in RFC 9000.\r\n\r\nClosing this issue.",
          "createdAt": "2021-10-25T16:49:40Z",
          "updatedAt": "2021-10-25T16:49:40Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDODddxTs49DkXP",
      "title": "Ignore-order can cause high queuing and even packet loss",
      "url": "https://github.com/quicwg/ack-frequency/issues/93",
      "state": "CLOSED",
      "author": "goelvidhi",
      "authorAssociation": "NONE",
      "assignees": [
        "janaiyengar"
      ],
      "labels": [
        "design",
        "needs-pr"
      ],
      "body": "I don't fully understand when would someone want to set ignore-order = true, i.e., what is a valid use case for this?\r\n\r\nLets say for whatever reason the sender sets this to True, this would if there is actual packet loss and receiver receives OOO packets, it won't send an immediate ACK. Meaning the sender won't enter loss recovery immediately and will continue sending packets at the same rate. This is not good, as it directly increases queuing on the network node and for a tail drop queue (most widespread deployment), it will also affect other flows. Meaning, other flows will experience packet loss due to non-responsiveness of this flow for certain period of time.\r\n\r\nI probably missed past conversations about ignore-order field, so my apologies if this has already been discussed. I read the draft and didn't see any explanation about where would this be useful and what are the fallbacks of setting this to true.",
      "createdAt": "2021-10-12T20:37:41Z",
      "updatedAt": "2021-10-25T17:40:56Z",
      "closedAt": "2021-10-25T17:40:56Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "One use case that I know and care is for sending QUIC traffic from a server cluster.\r\n\r\nSome packets would be sent directly from a server node that governs the connections, but others would be sent via different nodes within the same cluster. Once we deploy a sender like this, the receiver would observe what looks like reordering (because most packets will be essentially delivered through an additional hop, and that would cause delays). But we do not want the receiver to send ACK for each packet being received.\r\n\r\nRegarding the problem, I'm not sure I agree with the impact. Typically, congestion controllers react to congestion after 1 RTT. When packet-number-based detection is turned off, that changes to 9/8 RTT.\r\n\r\nThat does cause more pressure on the bottleneck queue, but it is no worse than that caused by a path with an 9/8 greater RTT.\r\n\r\nAssuming that congestion controllers are designed to be fair against flows having different RTTs, I tend to believe that this is a non-issue.",
          "createdAt": "2021-10-12T21:28:38Z",
          "updatedAt": "2021-10-12T21:28:38Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @kazuho  though I think adding a SHOULD NOT use a delay longer than an RTT(https://github.com/quicwg/ack-frequency/issues/72#issuecomment-941561257) would be a good addition, since if the delay is extremely large(ie multiple RTTs), that could be bad.",
          "createdAt": "2021-10-12T21:31:33Z",
          "updatedAt": "2021-10-12T21:31:33Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "In general, the spirit of this draft is to provide control over acking behavior to the sender, since it is the consumer of this information and ought to be able to control how frequently it needs to see this information. If there are subtle consequences to these decisions, it is worth noting them in the draft.\r\n\r\nIt seems useful to add some text on the consequences of using Ignore Order, so that senders can make informed decisions. We can do that.",
          "createdAt": "2021-10-12T23:35:08Z",
          "updatedAt": "2021-10-12T23:35:08Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "> One use case that I know and care is for sending QUIC traffic from a server cluster.\r\n> \r\n> Some packets would be sent directly from a server node that governs the connections, but others would be sent via different nodes within the same cluster. Once we deploy a sender like this, the receiver would observe what looks like reordering (because most packets will be essentially delivered through an additional hop, and that would cause delays). But we do not want the receiver to send ACK for each packet being received.\r\n\r\n@kazuho is this something that Fastly does or is planning to do? How would you share the connection secrets between different server nodes?\r\n\r\n> Regarding the problem, I'm not sure I agree with the impact. Typically, congestion controllers react to congestion after 1 RTT. When packet-number-based detection is turned off, that changes to 9/8 RTT.\r\n> That does cause more pressure on the bottleneck queue, but it is no worse than that caused by a path with an 9/8 greater RTT.\r\n\r\nWhen we set ignore-reorder = true, and lets assume that max ACK delay > 1RTT, it can be 1RTT or 2 or 10RTT. this would result in loss recovery to be delayed by at least an additional RTT, i.e. it will take >16/8RTT (>2RTT) instead of 9/8RTT to declare packets lost. That is significant IMO.\r\n\r\n>Assuming that congestion controllers are designed to be fair against flows having different RTTs, I tend to believe that this is a non-issue.\r\n\r\nCUBIC throughput is inversely proportional to RTT in New Reno mode. Nonetheless, I am more concerned about high queuing in bottleneck due to late loss recovery.\r\n\r\nSpecifying the use-cases where ignore-order = true SHOULD be used will prevent new implementors from using it randomly. And as Jana said, some text around the consequences when it is used would allow informed decision making.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-10-14T01:08:14Z",
          "updatedAt": "2021-10-14T01:09:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@goelvidhi I do not speak for Fastly's plan, but the OSS branch of H2O has a working prototype that does this: https://github.com/h2o/h2o/pull/2415.\r\n\r\n> When we set ignore-reorder = true, and lets assume that max ACK delay > 1RTT, it can be 1RTT or 2 or 10RTT. this would result in loss recovery to be delayed by at least an additional RTT, i.e. it will take >16/8RTT (>2RTT) instead of 9/8RTT to declare packets lost. That is significant IMO.\r\n\r\nThe calculation is correct. At the same time, I do not think that senders will be willing to use Max Ack Delay as large as that, when setting the Ignore Order bit.\r\n\r\nThe problem here is the impact on loss recovery. If Max Ack Delay is set to a value as large as 1 RTT, then the sender needs to spend more than 2 RTTs for detecting a loss. That means that the size of the send and receive buffers have to be twice as large, and that it would take as twice as long to recover from a loss.\r\n\r\nBased on existing advice that we have in other RFCs, I think we should discourage Max Ack Delay that is greater than 9/8 RTT when Ignore Order bit is used (please see my comment on #72).",
          "createdAt": "2021-10-15T00:42:58Z",
          "updatedAt": "2021-10-15T00:42:58Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd suggest 5/4, but otherwise agree with you @kazuho ",
          "createdAt": "2021-10-15T16:28:21Z",
          "updatedAt": "2021-10-15T16:28:21Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Should the Max ACK Delay be restricted to 1/8 or 1/4 RTT as there is inherent 1RTT time spent while sending data and receiving ACKs? That would make a total of 1 + 1/8 or 1 +1/4 RTT total/",
          "createdAt": "2021-10-20T05:03:37Z",
          "updatedAt": "2021-10-20T05:03:37Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is best as a sender-side SHOULD, since it knows what time threshold it's using.  For example, we use 1/4 RTT, but have considered making it adaptive(ie: 1/16 RTT to 1 RTT) based on observed reordering.  Also, if your RTT is 100us, and your timers have coarser granularity, 1/8 RTT or 1/4 RTT just doesn't make sense.  I'm not sure what does, because I'm not an expert in datacenter networking, but that's why I think this is a SHOULD, not a MUST.\r\n\r\nOf course, it's also unenforceable, which is a good reason for a SHOULD.",
          "createdAt": "2021-10-20T12:57:40Z",
          "updatedAt": "2021-10-20T12:57:40Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "+1 to SHOULD.\r\n\r\nThe only argument I might disagree with @ianswett is that it is unenforceable (IMO a receiver can enforce by capping Ack Delay to a fraction of the RTT that the receiver has observed).\r\n\r\nBut I do not think there's any reason to require the receiver to enforce, considering the fact that a sender can send as many packets as it likes, regardless of ACKs the receiver sends (or lack of).",
          "createdAt": "2021-10-20T13:12:33Z",
          "updatedAt": "2021-10-20T13:12:33Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "I am fine with SHOULD and with a mention of how a sender would compute Max ACK Delay when he sets ignore-order = true.\r\nAn example is fine too.",
          "createdAt": "2021-10-21T07:46:08Z",
          "updatedAt": "2021-10-21T07:46:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is the same issue as #72 ",
          "createdAt": "2021-10-21T13:22:07Z",
          "updatedAt": "2021-10-21T13:22:07Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "There are two things that are impacted by setting a high value for ack delay: congestion control and time-threshold loss detection. On congestion control, we need some protection for the network, so we should recommend something. On loss detection, a sender that chooses `Ignore Order` and sets an ack delay higher than the time-threshold loss detection time period risks triggering unnecessary retransmissions. So, I propose adding the following for a sender:\r\n- SHOULD set the ack frequency to be at least one ack per RTT (so that congestion control responses are reasonably quick)\r\n- a word of caution that setting the ack delay to be longer than time threshold can cause the sender to unnecessary retransmit",
          "createdAt": "2021-10-21T13:39:59Z",
          "updatedAt": "2021-10-21T13:39:59Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "I_kwDODddxTs49dQcN",
      "title": "latency required to detect packet reordering threshold",
      "url": "https://github.com/quicwg/ack-frequency/issues/96",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "design",
        "needs-pr"
      ],
      "body": "Per [Section 6.1.1 of RFC 9002](https://www.rfc-editor.org/rfc/rfc9002.html#section-6.1.1-1), the recommended value of packet reordering threshold is 3. That means that with vanilla QUIC v1, the sender would notice a single packet loss without any ack delay being introduced by the receiver. That's because when the receiver notices a gap, it sends an ACK immediately, then after receiving two more packets, it sends another ACK immediately.\r\n\r\nWith the ack-frequency extension, this behavior changes.\r\n\r\nWhen the receiver notices a gap, one ACK is sent immediately. But after that, the next ACK will not be sent until the expiry of one of the thresholds being declared by the ACK_FREQUENCY frame.\r\n\r\nTo give an example, let's say that Ack-Eliciting Threshold is set to 1/8 of CWND, and Request Max Ack Delay is set to 1/8 of RTT.\r\n\r\nThen, when there is one packet loss (or one range of packets being lost), the sender cannot notice that packet loss based on the packet reordering threshold until 9/8 RTT after the packet(s) was being sent.\r\n\r\nIs this going to be an issue for QUIC performance? I ask this because, compared to TCP, many have highlighted the improved efficiency of recovery in QUIC as one of the benefits.",
      "createdAt": "2021-10-20T07:37:32Z",
      "updatedAt": "2021-11-11T04:52:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "I recall discussing something of sort in #34 and #35, but I'm not sure if we considered these side effects enough. IIRC, we abandoned the discussion to replace Ignore Order bit with Reordering Threshold, partly because we could not find a design that is easy to implement.\r\n\r\nBut now, I think I might have a solution.\r\n\r\nWe could:\r\n* Replace the Ignore Order field with a Reordering Threshold field.\r\n* State that receiver SHOULD ack every 2 packets that it receives, whenever the number of packets contained in the highest ACK range is no greater than that threshold.\r\n\r\nA sender that uses a threshold of 3 can advertise Reordering Threshold of 3 for example, to expect an immediate ACK to be sent when the receiver receives 3 packets after a gap. Or, a sender can advertise 5 instead, so that the loss would be noticed at an early moment even when there is an ACK loss.\r\n\r\nWDYT?",
          "createdAt": "2021-10-20T08:00:41Z",
          "updatedAt": "2021-10-20T08:03:51Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This is exactly what I was trying to mitigate with #35, but I think you explained the issue better than I did.\r\n\r\nWith the current algorithm, QUIC would end up falling back to the time threshold loss detection, opposed to packet threshold, so it wouldn't be that bad, but there could be a delay.\r\n\r\nI'd like to agree on the properties we want.  I think we want to ensure either time threshold or packet threshold are able to be triggered as quickly as possible.  Given that, I think we need to send one (at least relatively, see last paragraph) immediate ACK upon observing out of order packets.  That ensures that if only one packet arrives after the missing packet, it is detected in a timely manner by time threshold.  Second, I think we want to avoid sending any other ACKs except the one which will trigger packet threshold.  So the slightly complex bit is getting the algorithm for the second part correct.\r\n\r\nIf you agree with the above goals, I think we need something a bit more complex than what you proposed.  ie: What if the reordering threshold is 5 and you receive LostPN + 1, then LostPN+3, so there are already multiple ranges between the packet that could be declared lost and the reordering threshold.\r\n\r\nI'll try to describe and algorithm for that second ACK:\r\n- Track the largest_acknowledged_sent in an ACK\r\n- When there are missing packets in the range `[largest_acknowledged_sent - Reordering Threshold, largest_acknowledged - Reordering Threshold]`, send an immediate ACK.\r\n\r\nAdditionally, I think we should point out that small scale reordering(ie: 1 packet or twiddles) are the most common, so it makes sense to process an entire batch of available packets before determining whether to send an immediate acknowledgement.  \r\n",
          "createdAt": "2021-10-20T13:39:53Z",
          "updatedAt": "2021-11-10T13:46:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "> This is exactly what I was trying to mitigate with #35, but I think you explained the issue better than I did.\r\n\r\nI see, sorry for revisiting the issue. I hope we'd resolve the issue correctly this time.\r\n\r\n> I'd like to agree on the properties we want. \r\n\r\nMakes sense. The properties that I had in my mind were slightly different from what you have:\r\n* send ACKs no more than vanilla QUIC v1\r\n* send ACKs to make sure that losses are detected as early as vanilla QUIC v1\r\n* provide opportunity to deal with ACK-losses, so that even when there are ACK losses, losses can be detected as early as vanilla QUIC v1\r\n\r\nThe reason I would not mind sending two or three ACKs to indicate one gap is because packet losses are rare. Let\u2019s say that average packet loss ratio is 1%. Then, assuming Reordering Threshold of 3, the debate is between if the number of ACKs being sent in response to gaps would be ~1% of the packets that the sender sends, or ~2% of the packets that the sender sends (in case of the algorithm described in https://github.com/quicwg/ack-frequency/issues/96#issuecomment-947423006).\r\n\r\nI must admit that the number of ACKs used for indicating one gap increases relative to the Reordering Threshold, but I\u2019m not sure if we want to use values above 3.\r\n\r\nAll that said, I would be fine with the properties you describe, as I think the required algorithm is going to be simple enough, and because ACK loss is not a big problem assuming that packet losses are rare in general.\r\n\r\n**Please Ignore my comments below this line, I see the algorithm being corrected in the comment above :+1:**\r\n\r\nThough I think there's a tiny bug in the algorithm being proposed:\r\n\r\n> * When the new largest acknowledged is: `>= (smallest missing PN greater than largest_acknowledged_sent) - Reordering Threshold`, send an immediate ACK.\r\n\r\nI think this should be something like:\r\n* When the new largest acknowledged is : `>= (smallest missing PN greater than (largest_acknowledged_sent - Reordering Threshold)) - Reordering Threshold`, send an immediate ACK.\r\n\r\nOtherwise, if an ACK is sent due to other reasons immediately after a gap, then that gap would not be notified at the earliest moment. One example is PN=255 being lost, then PN=256 received and ACK being sent due to Ack-Eliciting Threshold. When the receiver receives PN=257 and PN=258, then it should send an immediate ACK, assuming Reordering Threshold of 3.",
          "createdAt": "2021-10-20T14:25:29Z",
          "updatedAt": "2021-10-20T22:02:29Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I just updated my suggested algorithm, and I think it now matches yours, but is stated differently?\r\n\r\nWe use adaptive reordering, so it's not uncommon for our threshold to be 10+, which is 5 extra ACKs.  Also, the every 2 option still requires the time threshold detection if you get one too few packet, whereas you could send an ACK at exactly the right threshold and the peer would immediately declare a loss.  Not a big deal, but it's slightly suboptimal.",
          "createdAt": "2021-10-20T14:32:03Z",
          "updatedAt": "2021-10-20T14:32:03Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "+1 to everything @ianswett says right above.",
          "createdAt": "2021-10-20T22:03:34Z",
          "updatedAt": "2021-10-20T22:03:34Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "As I said on the mike during the WG meeting, there are two ways of distinguishing expected renumbering from packet losses. One is to check sequence numbers, and assume packet loss if >N packets received after hole. Another is a to check a reordering delay, if >T passes and the hole is still there. What I found in practice is that reordering delay thresholds work better than reordering number thresholds. Would be nice if the PR allowed for specifying a reordering delay, independent of the already specified ACK delay.",
          "createdAt": "2021-11-10T12:35:14Z",
          "updatedAt": "2021-11-10T12:35:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "So let me understand the goal: you want to force an acknowledgment if a gap persists.\r\n\r\nA gap appears because a packet with a larger packet number is received.  Then:\r\n\r\nTime:\r\nAt that time, start a timer for some time less than the maximum acknowledgment delay and send an acknowledgment if the packet is still missing when the timer pops.  (I'm not sure how to do this without having a timer running for every missing packet.)\r\n\r\nNumber:\r\nThis only requires that N packets after the gap arrive.  I think that I understand Ian's algorithm for this.",
          "createdAt": "2021-11-10T12:51:49Z",
          "updatedAt": "2021-11-10T12:51:49Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "In practice, you check the time of arrival of the following packets, and if the gap-delay is exceeded you fire the ACK.",
          "createdAt": "2021-11-10T14:07:24Z",
          "updatedAt": "2021-11-10T14:07:24Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@huitema I think the point here is that the receiver has to remember _when_ each packet was received, in addition to the packet numbers. That means that QUIC stacks have to change to the design of their ack queue, which makes this extension something much harder to implement than what it is now. At the moment, this extennion does not require changes to existing data structure.\r\n\r\nSeparately, I am not sure how valuable it is to specify a signalling mechanism for time-based gap detection.\r\n\r\nACK_FREQUENCY frame already has Request Max Ack Delay field for time-based signalling. Senders can set this value to a fraction of RTT (e.g., 9/8 RTT) to induce ACK earlier than when the senders' time-based loss detection should be kicked.\r\n\r\nSuch approach does have the downside of Inducing ACKs regardless of having gaps. But IMO, that is not a big issue, because:\r\n* Most congestion controllers require ACKs to be sent within a fraction of RTT.\r\n* Reducing the number of ACKs from one per two ack-eliciting packets to one per fraction of RTT is important (because the reduction of ACKs by their numbers is huge), but going below that is not important.\r\n\r\nConsidering these aspects, I am personally happy with _only_ having the packet-number based gap reporting mechanism as proposed by Ian in #100. ",
          "createdAt": "2021-11-11T01:08:42Z",
          "updatedAt": "2021-11-11T01:08:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@kazuho I suppose that there is some equivalence between \"wait for N packets\" and \"wait for T milliseconds\". If I had to not use a time delay, I would set N = CWIN*T/RTT. Or vice versa. After all, the scope of the reordering is either a fraction of the CWIN or a fraction of the RTT, depending how you look at it. I get the feedback that reasoning on packet numbers is easier for several implementations, so OK. Let's just use packet numbers.",
          "createdAt": "2021-11-11T04:52:57Z",
          "updatedAt": "2021-11-11T04:52:57Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDODddxTs4-R1Tw",
      "title": "Wording only: \"Generally...MUST\"",
      "url": "https://github.com/quicwg/ack-frequency/issues/103",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"Generally, when using max_ack_delay for PTO computations, endpoints MUST use the maximum of the current value and all those in flight.\"\r\n\r\n- I think the words generally and MUST do not sit well together, and it would be better to say what is the requirement.\r\n",
      "createdAt": "2021-11-04T15:03:54Z",
      "updatedAt": "2021-11-04T15:03:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 104,
      "id": "I_kwDODddxTs4-R15U",
      "title": "9.5.  Path MTU Discovery ",
      "url": "https://github.com/quicwg/ack-frequency/issues/104",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A sender might use timers to detect loss of PMTUD probe packets.  A sender SHOULD bundle an IMMEDIATE_ACK frame with any PTMUD probes to avoid triggering such timers.\r\n\r\n- This seems also valuable for DPLPMTUD.\r\n",
      "createdAt": "2021-11-04T15:06:04Z",
      "updatedAt": "2021-11-04T15:06:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 105,
      "id": "I_kwDODddxTs4-R2Rz",
      "title": "NiT or more?",
      "url": "https://github.com/quicwg/ack-frequency/issues/105",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "9.4.  Connection Migration\r\n.... \" it sends or it can simply send an IMMEDIATE_ACK frame\"\r\n- What is the intended difference between the words \"it sends\" or \"it can simply send\"?\r\n",
      "createdAt": "2021-11-04T15:07:27Z",
      "updatedAt": "2021-11-04T17:47:53Z",
      "closedAt": "2021-11-04T17:47:53Z",
      "comments": []
    },
    {
      "number": 106,
      "id": "I_kwDODddxTs4-R4aA",
      "title": "Can we be clearer about the nature of any CC tradeoffs",
      "url": "https://github.com/quicwg/ack-frequency/issues/106",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Current text says:\r\n\"   Similarly, if these controllers rely on the\r\n   timing of peer acknowledgments (an \"ACK clock\"), delaying\r\n   acknowledgments will cause undesirable bursts of data into the\r\n   network.\"\r\n\r\n- PR#75 was closed, but I think this is still open? - The current text seems cryptic to me. Do the bursts really impact the congestion control design?  - I can see ACK frequency changes could cause undesirable bursts of data, and those bursts could, in turn, induce congestion - can we explain that. Especially since RFC9000 also seems to say these bursts could be mitigated by pacing, and also they could be controlled in some other way to be less than a maximum burst size (e.g. Max burst). I'd still argue that QUIC has a behaviour which expects bursts of upto 10 packets, and that this argues that pacing at least right now to mitigate bursts larger than the size of IW. Such burst mitigations are not without their own tradeoffs.\r\n-  The ACK_Frequency frame can postpone reporting loss, are there other impacts?",
      "createdAt": "2021-11-04T15:15:12Z",
      "updatedAt": "2021-11-04T15:15:12Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDODddxTs4-R6WP",
      "title": "Bounds on safe use of \"Ignore CE\" for ECT(1)? ",
      "url": "https://github.com/quicwg/ack-frequency/issues/107",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- To me, Ignore CE for arbitrary numbers of packets, does seem like it can be quite dangerous to the proper operation of ECN in the way understood for ECT(1), unless this is somehow constrained on the number of packets that are received. ECN is intended to be an early reaction to congestion and this delays a CC reaction, and if it is for a lot of packets I think that's likely an issue, although a few packets would likely be fine !!!! I think this needs CC safety guidance in the text, even if the guidance differs for ECT(0).\r\n",
      "createdAt": "2021-11-04T15:22:10Z",
      "updatedAt": "2021-11-10T12:45:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "I agree with this but probably the sender wouldn't use both Ignore-CE and L4S at the same time. Hopefully, folks will understand that from reading the draft. :-)",
          "createdAt": "2021-11-10T12:36:55Z",
          "updatedAt": "2021-11-10T12:36:55Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "Hmmmm ... If this *really*  only applies to sender setting ECT(0) let's say that - I can see it works in relation to ABE or RFC3168 reactions, and not L4S. Explaining this, the impact would then be clear when (?) ECT(0) usage is finally deprecated. Likely a PR can achieve this.  ",
          "createdAt": "2021-11-10T12:45:31Z",
          "updatedAt": "2021-11-10T12:45:31Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDODddxTs4-kK_L",
      "title": "Expediting Congestion Signals",
      "url": "https://github.com/quicwg/ack-frequency/issues/109",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "First, in section 4 I think the wrong section is referenced:\r\n\r\n   Ignore CE:  A 1-bit field representing a boolean truth value.  This\r\n      field is set to true by an endpoint that does not wish to receive\r\n      an immediate acknowledgement when the peer receives CE-marked\r\n      packets (Section 7.1). 0 represents 'false' and 1 represents\r\n      'true'.\r\n\r\nThat should be Section 7.2 should it not? Please use symbolic links to avoid this issue.\r\n\r\nComparing 7.1 and 7.2 I think there is inconsistency in structure. I think that 7.2 needs the corresponding link back to the ACK_FREQUENCY frame feature for controlling this behavior.",
      "createdAt": "2021-11-10T10:47:07Z",
      "updatedAt": "2021-11-10T13:06:07Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 110,
      "id": "I_kwDODddxTs4-kPcs",
      "title": "Computation of Probe Timeout Period",
      "url": "https://github.com/quicwg/ack-frequency/issues/110",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`   When the number of in-flight ack-eliciting packets is larger than the\r\n   ACK-Eliciting Threshold, an endpoint can expect that the peer will\r\n   not need to wait for its max_ack_delay period before sending an\r\n   acknowledgement.  In such cases, the endpoint MAY therefore exclude\r\n   the peer's 'max_ack_delay' from its PTO calculation.  Note that this\r\n   optimization requires some care in implementation, since it can cause\r\n   premature PTOs under packet loss when ignore_order is enabled.`\r\n\r\nIsn't this oversimplifying things so that the aspect of time until an ACK is expected to be sent is removed? To me it is not that max_ack_delay is removed completely from \r\nhttps://www.rfc-editor.org/rfc/rfc9002.html#name-computing-pto\r\n\r\nPTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay\r\n\r\nInstead it is replaced with expected time until the sender have sent ACK-Eliciting Threshold number of packets when that is less than max_ack_delay that is configured. \r\n\r\nSecondly, are you expecting the sender to make an estimate of how many packets more are received before an ACK is sent, i.e. care about what phase it is currently when calculating the PTO in regards to which packet is expected to trigger the next ACK? However, that is clearly prone to be wrong if there is a loss occurring currently who's loss indicating ack has not yet been received by the sender.  \r\n\r\nSo it appears to me that this allowance is by default creating a situation which will cause premature PTOs, and it would be better to put some restrictions on it.",
      "createdAt": "2021-11-10T11:06:28Z",
      "updatedAt": "2021-11-10T11:06:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 111,
      "id": "I_kwDODddxTs4-ks5c",
      "title": "Guidance on choice of acknowledgment frequency for app-limited sender",
      "url": "https://github.com/quicwg/ack-frequency/issues/111",
      "state": "OPEN",
      "author": "goelvidhi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thank you for adding the guidance on a sender's choice of acknowledgment frequency.  In the below text, I think we need to be careful about one more scenario - app limited sending behavior. If the sender is sending in a stop and go manner, and it creates ACK_FREQUENCY such that it receives one ACK per cwnd (ack-eliciting threshold) or an estimated RTT (Request Max Ack Delay), then it could take a total of 2 RTT for the ACK to come back.\r\n\r\n`A sender can accomplish this by\r\n sending an IMMEDIATE_ACK frame once per round-trip time (RTT), or it can set the\r\n Ack-Eliciting Threshold and Request Max Ack Delay values to be no more than a\r\n congestion window and an estimated RTT, respectively.`\r\n\r\nFor example, if RTT = R\r\n1. sender sends after long idle period at time t (there are no outstanding bytes in flight)\r\n2. receiver receive packet at t + R/2 (one way propagation time)\r\n3. receiver waits for 1R and then sends ACK\r\n4. sender will receive ACK at (t+R/2) + 1R ( Max ack delay) + R/2\r\n\r\nPerhaps, we could handle the app-limited scenario in guidance by saying, \r\n1. An app-limited sender SHOULD send an IMMEDIATE_ACK frame at the start of a new send cycle OR\r\n2. (More generic solution) The receiver SHOULD send an ACK after,\r\nMIN( time equivalent to Request Max Ack Delay has elapsed from the last ACK, Request Max Ack Delay from when it received data)\r\n\r\nI like option 2 as this covers the different sending behaviors.\r\n\r\n",
      "createdAt": "2021-11-10T13:09:40Z",
      "updatedAt": "2021-11-10T13:09:40Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzAyMzgx",
      "title": "Change Time Tolerance to Update Max Ack Delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/4",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes a few things:\r\n- Introduces a `min_ack_delay` TP for negotiating extension use\r\n- Changes `Time Tolerance` to `Update Max Ack Delay`\r\n- Makes the fields required\r\n- Specifies invalid values\r\n\r\nCloses #2.",
      "createdAt": "2020-01-17T20:15:30Z",
      "updatedAt": "2020-01-17T20:29:06Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "e95015dedcd85f71f3109160323aac0713023629",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/update-mad",
      "headRefOid": "65b71253ca21f0a95ad47240f717928c6e30a27a",
      "closedAt": "2020-01-17T20:29:05Z",
      "mergedAt": "2020-01-17T20:29:05Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "960e862fb19ca11f2285121b32270db46c139103"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm merging this, let's address issues in later PRs.",
          "createdAt": "2020-01-17T20:29:00Z",
          "updatedAt": "2020-01-17T20:29:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzM1NDkz",
      "title": "Add section on PTO computation with updated max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/7",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #1.",
      "createdAt": "2020-01-17T21:58:26Z",
      "updatedAt": "2020-01-17T21:59:36Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "960e862fb19ca11f2285121b32270db46c139103",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/pto",
      "headRefOid": "11fbdcd13c2250094e7216576c9d032709f0d0ee",
      "closedAt": "2020-01-17T21:59:36Z",
      "mergedAt": "2020-01-17T21:59:36Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "fc3eb17d4cf79f371ec138c26371e78ecc4d9b8b"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-17T21:59:30Z",
          "updatedAt": "2020-01-17T21:59:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzQ4NTYy",
      "title": "Add sequence number to frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/8",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #5.",
      "createdAt": "2020-01-17T22:46:39Z",
      "updatedAt": "2020-01-17T22:47:58Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "fc3eb17d4cf79f371ec138c26371e78ecc4d9b8b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/seqnum",
      "headRefOid": "6529108ccdbcec4f86ee9e6340124f0df66c3e59",
      "closedAt": "2020-01-17T22:47:58Z",
      "mergedAt": "2020-01-17T22:47:58Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "0b23026b4f9760a2ab0325dcef702770cbaee3ed"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-17T22:47:52Z",
          "updatedAt": "2020-01-17T22:47:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzUyMTkw",
      "title": "Handle initial conditions",
      "url": "https://github.com/quicwg/ack-frequency/pull/9",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... and some editorializing.",
      "createdAt": "2020-01-17T23:02:08Z",
      "updatedAt": "2020-01-17T23:02:30Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0b23026b4f9760a2ab0325dcef702770cbaee3ed",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/initial",
      "headRefOid": "bf23ce91fd410dcef64ff53b4e561828469cf795",
      "closedAt": "2020-01-17T23:02:30Z",
      "mergedAt": "2020-01-17T23:02:30Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "254044e375d9517b107a2d789534d466b344caa4"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-17T23:02:21Z",
          "updatedAt": "2020-01-17T23:02:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzYzOTcy",
      "title": "Add reordering tolerance",
      "url": "https://github.com/quicwg/ack-frequency/pull/10",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #6.",
      "createdAt": "2020-01-18T00:00:59Z",
      "updatedAt": "2020-01-18T00:01:17Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "254044e375d9517b107a2d789534d466b344caa4",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/reordering",
      "headRefOid": "e6dbc9a96c2f02d6556e205c044515b16aa678a3",
      "closedAt": "2020-01-18T00:01:17Z",
      "mergedAt": "2020-01-18T00:01:16Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "06792883fc189e7296ea0fcf48e96bdd9b127e4a"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-18T00:01:11Z",
          "updatedAt": "2020-01-18T00:01:11Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzY5Nzk4",
      "title": "Add references, add Frame Type field to ACK-FREQUENCY frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/11",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-18T00:33:57Z",
      "updatedAt": "2020-01-18T00:48:03Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "3a7ca17cd9c65cf3073ee63d991374318e985659",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/refs",
      "headRefOid": "d1677752b7ed819995d6ced4b4c7a6ed0f64beaa",
      "closedAt": "2020-01-18T00:48:03Z",
      "mergedAt": "2020-01-18T00:48:03Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "ee639b160220d60b87fe03689a459049247b7d02"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1MDYyNjEy",
      "title": "Editorial comments",
      "url": "https://github.com/quicwg/ack-frequency/pull/12",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Plus fixing one spot where it said 2^14, but I think it should have been 2^24",
      "createdAt": "2020-01-21T02:03:39Z",
      "updatedAt": "2020-01-21T18:41:05Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0402c2a1f495dae0a97a19a9fbfb11bc9afcff0c",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-editorial",
      "headRefOid": "8f28d22bee0aaccd82323410ea50854309445a24",
      "closedAt": "2020-01-21T18:41:05Z",
      "mergedAt": "2020-01-21T18:41:05Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "c45b03bbe836e6321f12a0373544b247c117ac9b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTAzODQw",
          "commit": {
            "abbreviatedOid": "8f28d22"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T18:40:59Z",
          "updatedAt": "2020-01-21T18:40:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NDUwNzgy",
      "title": "A few more suggestions",
      "url": "https://github.com/quicwg/ack-frequency/pull/13",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changed the error code to FRAME_ENCODING_ERROR and removed a condition for update which I think may end up causing correctness issues.",
      "createdAt": "2020-01-21T18:35:52Z",
      "updatedAt": "2020-01-21T20:21:30Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0402c2a1f495dae0a97a19a9fbfb11bc9afcff0c",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-editorial2",
      "headRefOid": "8996a31f11771c95d07083b826703d9be5cfa8e1",
      "closedAt": "2020-01-21T20:21:30Z",
      "mergedAt": "2020-01-21T20:21:30Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "b78e2486498a51aacdb7b6681709f40eff40a157"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I removed the comment you thought was unnecessary, and we can discuss it and any other changes to the section separately.",
          "createdAt": "2020-01-21T19:16:01Z",
          "updatedAt": "2020-01-21T19:16:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTA0Njk1",
          "commit": {
            "abbreviatedOid": "c09c66a"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T18:42:23Z",
          "updatedAt": "2020-01-21T18:50:10Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I don't think this is necessary. The TP says nothing about ECN, and ECN says nothing about reordering.",
              "createdAt": "2020-01-21T18:42:23Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nfrom the most recent frame (frame with the highest sequence number) that was acknowledged.\r\n```",
              "createdAt": "2020-01-21T18:43:38Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nMUST use the maximum of the current value and all those in flight.  If there are\r\n```",
              "createdAt": "2020-01-21T18:44:00Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nACK-FREQUENCY frames in flight, then endpoints MUST use the `max_ack_delay` value\r\n```",
              "createdAt": "2020-01-21T18:48:42Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTI1ODkx",
          "commit": {
            "abbreviatedOid": "8996a31"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T19:16:16Z",
          "updatedAt": "2020-01-21T19:16:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Removed.",
              "createdAt": "2020-01-21T19:16:16Z",
              "updatedAt": "2020-01-21T19:16:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTY1MjMx",
          "commit": {
            "abbreviatedOid": "8996a31"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T20:21:02Z",
          "updatedAt": "2020-01-21T20:21:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NDUzNzE3",
      "title": "Editorial for undesirable consequence",
      "url": "https://github.com/quicwg/ack-frequency/pull/15",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Small readability tweaks",
      "createdAt": "2020-01-21T18:43:56Z",
      "updatedAt": "2020-01-21T20:22:06Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "c45b03bbe836e6321f12a0373544b247c117ac9b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-editorial3",
      "headRefOid": "3fdeed2d74c382a3dc7c5b79297c0344028a422a",
      "closedAt": "2020-01-21T20:22:06Z",
      "mergedAt": "2020-01-21T20:22:06Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "7e2a9ce4a05201d4049794cc8ef1c75393658032"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTY1NzUw",
          "commit": {
            "abbreviatedOid": "3fdeed2"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T20:22:01Z",
          "updatedAt": "2020-01-21T20:22:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NDk3NzA5",
      "title": "Re-introduce text that was inadvertently removed",
      "url": "https://github.com/quicwg/ack-frequency/pull/16",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "and reflow some text.",
      "createdAt": "2020-01-21T20:31:17Z",
      "updatedAt": "2020-01-21T21:11:43Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "7e2a9ce4a05201d4049794cc8ef1c75393658032",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/fixtext",
      "headRefOid": "074576cbea9937431f380f30537f99bc7caebc1c",
      "closedAt": "2020-01-21T21:11:43Z",
      "mergedAt": "2020-01-21T21:11:43Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "c111991f576015fa11cb6c3e575c3a44412fdd0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTcyMjM2",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T20:33:25Z",
          "updatedAt": "2020-01-21T20:33:26Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I intentionally removed this, because I think it results in indeterminate behavior.  I think you either need to use packet number or sequence number, not both.",
              "createdAt": "2020-01-21T20:33:25Z",
              "updatedAt": "2020-01-21T20:56:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTc0MTEy",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T20:36:42Z",
          "updatedAt": "2020-01-21T20:36:43Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Ok, I misread this the first time as packet number for some reason.  I think we need to find a different term besides sequence number at some point.  Also, when is sequence number capitalized?  It seems other fields in the frame always are.",
              "createdAt": "2020-01-21T20:36:43Z",
              "updatedAt": "2020-01-21T20:56:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTc0MTYx",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T20:36:47Z",
          "updatedAt": "2020-01-21T20:36:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTg1ODEx",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T20:57:19Z",
          "updatedAt": "2020-01-21T20:57:20Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I had packet number earlier, but that was mistakenly left over. That should simply have been changed to sequence number, which is what this PR does.\r\n\r\nThe rule we've used is field names are capitalized, but when talking about the concept, it's not. (\"sequence number of the frame\" vs \"Sequence Number field in the frame\"). This is the same as how we did sequence number of NCID frames in the transport draft -- both cases are used in the same manner.",
              "createdAt": "2020-01-21T20:57:20Z",
              "updatedAt": "2020-01-21T20:57:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4Nzc2MzE3",
      "title": "Define codepoints for the transport param and frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/21",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also rename ACK-FREQUENCY to ACK_FREQUENCY to Fix #19 ",
      "createdAt": "2020-01-29T21:33:37Z",
      "updatedAt": "2020-01-31T02:49:44Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "c111991f576015fa11cb6c3e575c3a44412fdd0e",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-codepoints",
      "headRefOid": "51d932182544da7ccfc28b070c26ac451dccd2aa",
      "closedAt": "2020-01-31T02:49:44Z",
      "mergedAt": "2020-01-31T02:49:44Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "3b23c62e6bdb5f5a483a6dfeb73bd2e2030e0f67"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4ODA1MjMx",
      "title": "Remove mention of slow start and hystart",
      "url": "https://github.com/quicwg/ack-frequency/pull/23",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #14  by removing references to slow start, hystart, and paced chirping.\r\n\r\nSlow start and BBR startup aren't quite the same as @mjoras mentioned, hystart isn't specified for QUIC, and paced chirping is not an IETF draft to my knowledge.",
      "createdAt": "2020-01-29T22:47:38Z",
      "updatedAt": "2020-01-31T02:50:22Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "c111991f576015fa11cb6c3e575c3a44412fdd0e",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-remove-mentions",
      "headRefOid": "e8a98fb32d556a85410faeeb44ad1edd730a5143",
      "closedAt": "2020-01-31T02:50:22Z",
      "mergedAt": "2020-01-31T02:50:22Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "59bc418cfc1dc4ea350b50897b5d83af00d90568"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcwMDY0MDk1",
      "title": "Use frame instead of TP for reordering",
      "url": "https://github.com/quicwg/ack-frequency/pull/24",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #18.",
      "createdAt": "2020-02-02T22:31:55Z",
      "updatedAt": "2020-02-03T16:23:12Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "59bc418cfc1dc4ea350b50897b5d83af00d90568",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/ignore-order",
      "headRefOid": "9c70e5961d8abd1b4bdec754af1263cc44a6f2dd",
      "closedAt": "2020-02-03T16:23:11Z",
      "mergedAt": "2020-02-03T16:23:11Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "8c88e17ec7acdbc62a9cb26443db47139576a75f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxOTgxNjAy",
          "commit": {
            "abbreviatedOid": "4953c04"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I prefer \"Ingnore Reordering\" to \"Ignore Order\", though I admit the latter is slightly shorter.  One suggestion on making the text slightly more proscriptive.",
          "createdAt": "2020-02-03T00:40:28Z",
          "updatedAt": "2020-02-03T00:48:35Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "How about \", the receiver MUST only send an acknowledgement in response to receiving Packet Tolerance packets or after the updated max_ack_delay has passed, and MUST NOT send an immediate acknowledgement in response to out of order packets.\"",
              "createdAt": "2020-02-03T00:40:29Z",
              "updatedAt": "2020-02-03T16:22:05Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nIgnore Reordering:\r\n```",
              "createdAt": "2020-02-03T00:45:11Z",
              "updatedAt": "2020-02-03T16:22:05Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nrecent frame received from the peer has an `Ignore Reordering` value of `false`\r\n```",
              "createdAt": "2020-02-03T00:46:29Z",
              "updatedAt": "2020-02-03T16:22:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTAxNTcy",
          "commit": {
            "abbreviatedOid": "4953c04"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T09:04:00Z",
          "updatedAt": "2020-02-03T16:22:28Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This doesn't fit within that space, if you can find a better way to write this out, happy to do it.",
              "createdAt": "2020-02-03T09:04:00Z",
              "updatedAt": "2020-02-03T16:22:28Z"
            },
            {
              "originalPosition": 43,
              "body": "I'm taking the second half of this, the first half seems unnecessary",
              "createdAt": "2020-02-03T09:06:48Z",
              "updatedAt": "2020-02-03T16:22:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxNzQxMzQ4",
      "title": "0 is a valid min_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/28",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #26",
      "createdAt": "2020-02-06T07:04:48Z",
      "updatedAt": "2020-02-06T07:11:19Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "8c88e17ec7acdbc62a9cb26443db47139576a75f",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-0-min-ack-delay",
      "headRefOid": "3f8b8e3b640413e8c47ce40437965653a7ef20db",
      "closedAt": "2020-02-06T07:11:18Z",
      "mergedAt": "2020-02-06T07:11:18Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "014ca67fd916f5a477fa6abb4a680ca86f51c56b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjM2NzUz",
          "commit": {
            "abbreviatedOid": "3f8b8e3"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-06T07:11:12Z",
          "updatedAt": "2020-02-06T07:11:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMzc5MTM3",
      "title": "Clarify when you might not retransmit",
      "url": "https://github.com/quicwg/ack-frequency/pull/29",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If there's a frame with a larger sequence number, there's no need to retransmit.",
      "createdAt": "2020-02-07T12:04:00Z",
      "updatedAt": "2020-02-27T23:27:06Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "014ca67fd916f5a477fa6abb4a680ca86f51c56b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-when-retransmit",
      "headRefOid": "b9b12132088c9e01acd43346565097b1389e0a2f",
      "closedAt": "2020-02-27T23:27:06Z",
      "mergedAt": "2020-02-27T23:27:06Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "0c59475c5eebf232679612a13fe8cc3b11731a5f"
      },
      "comments": [
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, looks good ;-)",
          "createdAt": "2020-02-08T10:58:03Z",
          "updatedAt": "2020-02-08T10:58:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1MDMzMTAw",
      "title": "Remove sections from motivations, add implementation considerations.",
      "url": "https://github.com/quicwg/ack-frequency/pull/31",
      "state": "MERGED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think the motivations section as-is is too long. It spends a lot of time\r\ntalking about what are effectively the tradeoffs. IMO the motivations section\r\nshould specify why it's useful to have the sender control the receiver's ACK\r\nfrequency, and then we can have a separate section for the tradeoffs.\r\n\r\nThis takes a stab at that section, lifting things from motivations and adding\r\nsome new text specifically addressing the nascent stages of a connection. \r\n\r\nI also made some editorial changes to the existing text.\r\n\r\nI am happy to add any additional considerations we think might need to be called out.\r\n\r\nThis attempts to resolve #17 ",
      "createdAt": "2020-02-13T18:53:22Z",
      "updatedAt": "2020-03-19T23:08:56Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0c59475c5eebf232679612a13fe8cc3b11731a5f",
      "headRepository": "mjoras/ack-frequency",
      "headRefName": "master",
      "headRefOid": "2e3c981e2711c2f8da242937246c69db291c3031",
      "closedAt": "2020-03-19T23:08:56Z",
      "mergedAt": "2020-03-19T23:08:55Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "eb364241a0eef02207841a05a1e20ba9cd072af3"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the PR, @mjoras ! I like the new text you propose (I've proposed some changes), but I think you might be assuming that ACK_FREQUENCY is only used for delaying acks further. An important point that bears bringing out in the motivation is that a sender might want more frequent acks as well, for example during startup. That's worth capturing in the modified motivation section.",
          "createdAt": "2020-02-27T23:38:29Z",
          "updatedAt": "2020-02-27T23:38:29Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@mjoras this PR is almost done, any chance you can do another round of updates and we can get it in?",
          "createdAt": "2020-03-07T10:30:23Z",
          "updatedAt": "2020-03-07T10:30:23Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett sorry, I'll do some updates today.",
          "createdAt": "2020-03-16T17:03:21Z",
          "updatedAt": "2020-03-16T17:03:21Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett @janaiyengar I've updated the PR, I'll watch and iterate on any remaining feedback quickly this time.",
          "createdAt": "2020-03-16T17:21:32Z",
          "updatedAt": "2020-03-16T17:21:32Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks @janaiyengar. Something about vim and the macbook pro keyboard apparently makes me incapable of spelling things properly. I want my desk keyboard back \ud83d\ude42 \r\n\r\n",
          "createdAt": "2020-03-19T20:01:18Z",
          "updatedAt": "2020-03-19T20:01:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTIzMDc3",
          "commit": {
            "abbreviatedOid": "7ed0a51"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "A few comments and sugestions.",
          "createdAt": "2020-02-13T20:19:56Z",
          "updatedAt": "2020-02-13T20:25:28Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The frequency only matters if there are packets that arrive out of order, so it might be worth stating that?",
              "createdAt": "2020-02-13T20:19:56Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 47,
              "body": "This is a good use of the word Nascent, but I don't believe nascent is a commonly used word in the congestion control world, so I'd be inclined to call this section \"New Connections\"",
              "createdAt": "2020-02-13T20:21:32Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 57,
              "body": "This section seems a bit odd down here given this draft adds an explicit signal for the sender to tell the receiver what ACK strategy it wants.  The section could be re-written to advise the sender to delay sending the ACK_FREQUENCY frame while it's reliant upon frequent acknowledgements to quickly ramp up the congestion controller, and remove the part about how the receiver needs to be cautious about changing its strategy.",
              "createdAt": "2020-02-13T20:24:51Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTUyMzE1",
          "commit": {
            "abbreviatedOid": "7ed0a51"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T21:09:15Z",
          "updatedAt": "2020-02-13T21:09:16Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I think I phrased this poorly. What I meant is that the _sender_ should be cautious in sending an ACK_FREQUENCY too early in the connection, as indeed the receiver is meant to be a passive actor in this decision making. I think we are on the same page here, I will rephrase.",
              "createdAt": "2020-02-13T21:09:15Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTUyNTkw",
          "commit": {
            "abbreviatedOid": "7ed0a51"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T21:09:44Z",
          "updatedAt": "2020-02-13T21:09:45Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Good point, I agree that's a good addition.",
              "createdAt": "2020-02-13T21:09:44Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDA1MjQw",
          "commit": {
            "abbreviatedOid": "aaed29f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "A few more suggestions, but it looks good.",
          "createdAt": "2020-02-25T19:55:05Z",
          "updatedAt": "2020-02-25T20:04:52Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nstrategies and find those which best suit their congestion controllers, applications, and networks.\r\n```",
              "createdAt": "2020-02-25T19:55:05Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 45,
              "body": "How about \"Consequently, a receiver that sends acknowledgements less frequently force the sender to wait for the time threshold instead of the packet threshold.\"?  Are there other specific examples you have in mind?",
              "createdAt": "2020-02-25T19:57:32Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\ncontroller will quickly increase the amount of data in the network until it is\r\n```",
              "createdAt": "2020-02-25T20:04:04Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDcyNzYy",
          "commit": {
            "abbreviatedOid": "aaed29f"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "A few comments",
          "createdAt": "2020-02-27T23:31:44Z",
          "updatedAt": "2020-02-27T23:36:26Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@ianswett : I don't think that's accurate, since the ack may be received before the time threshold period passes. I  prefer Matt's wording, since it's not necessary to wade into details here.",
              "createdAt": "2020-02-27T23:31:44Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nMany congestion control algorithms have a special state for the beginning\r\n```",
              "createdAt": "2020-02-27T23:31:59Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 60,
              "body": "I agree with the premise, but not with the recommendation. A sender might want to ask the receiver to ack every packet during this phase, and that needs an ACK_FREQUENCY frame. I think what you want to say here is not to advise caution, but to note that a sender could use the frame to make the receiver ack more frequently during this phase.",
              "createdAt": "2020-02-27T23:34:50Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzM2NjA1",
          "commit": {
            "abbreviatedOid": "aaed29f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-07T10:29:39Z",
          "updatedAt": "2020-03-07T10:29:39Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Fair point Jana, ignore my suggestion Matt.",
              "createdAt": "2020-03-07T10:29:39Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MjcyNDk5",
          "commit": {
            "abbreviatedOid": "7f1888f"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, @mjoras -- a few more suggestions.",
          "createdAt": "2020-03-18T22:13:40Z",
          "updatedAt": "2020-03-19T00:20:00Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nstrategies and find those which best suit their applications and congestion\r\n```",
              "createdAt": "2020-03-18T22:13:40Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nMany congestion control algorithms have a startup mechanism during the beginning\r\n```",
              "createdAt": "2020-03-18T22:14:40Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nof a connection.  It is typical that in this period the congestion controller\r\n```",
              "createdAt": "2020-03-18T22:14:55Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nacknowledgments at a rate which is optimal for the the sender's congestion\r\n```",
              "createdAt": "2020-03-18T22:15:20Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\ncongestion controller is in this state, ensuring that the receiver will send\r\n```",
              "createdAt": "2020-03-18T22:15:37Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\ncontroller's machinery.  A sender can send ACK_FREQUENCY frames while its\r\n```",
              "createdAt": "2020-03-18T22:15:58Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\ncontroller.\r\n```",
              "createdAt": "2020-03-18T22:16:35Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\ncontrollers rely on the timing of peer acknowledgments (an \"ACK clock\") to send\r\ndata, delaying acknowledgments will cause undesirable bursts of data into the\r\nnetwork.\r\n```",
              "createdAt": "2020-03-19T00:09:55Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 4,
              "body": "I think deleting this text here leads to the impression that there are only good things that can come out of reducing ACK rate, which leads to the question, why not simply reduce it. I think it's important to note the other points here, and maybe point to the considerations section. How about something like:\r\n\r\n> As discussed in {{implementation}}, there are undesirable consequences to a receiver unilaterally\r\n> reducing the acknowledgement frequency however, in terms of congestion control and loss\r\n> detection. Consequently, a sender needs the ability to express its constraints on the acknowledgement \r\n> frequency to maximize congestion controller performance.\"",
              "createdAt": "2020-03-19T00:18:01Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTUzMjUy",
          "commit": {
            "abbreviatedOid": "2e3c981"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @mjoras!",
          "createdAt": "2020-03-19T23:08:45Z",
          "updatedAt": "2020-03-19T23:08:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5Mzc0NzY2",
      "title": "use TRANSPORT_PARAMETER_ERROR",
      "url": "https://github.com/quicwg/ack-frequency/pull/32",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Use TRANSPORT_PARAMETER_ERROR for communicating errors in TP, rather than using PROTOCOL_VIOLATION.",
      "createdAt": "2020-04-06T04:37:02Z",
      "updatedAt": "2020-04-18T21:02:56Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "a2283352a7314e730d43681fdac31a54cfab2c7e",
      "headRepository": "kazuho/ack-frequency",
      "headRefName": "kazuho/error-code-for-tp",
      "headRefOid": "52a3464e435320737aefdd7ead30c3c326734321",
      "closedAt": "2020-04-18T21:02:56Z",
      "mergedAt": "2020-04-18T21:02:56Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "bc49468c91497a37105082eb50aa0fd5b2723858"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3OTI5MDY2",
          "commit": {
            "abbreviatedOid": "52a3464"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T04:38:11Z",
          "updatedAt": "2020-04-06T04:38:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMDIzNzQw",
      "title": "follow the practice of using PROTOCOL_VIOLATION for semantic errors",
      "url": "https://github.com/quicwg/ack-frequency/pull/33",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the specification requires the use of FRAME_ENCODING_ERROR when an endpoint receives an ACK_FREQUENCY frame with the value of Update Max Ack Delay field being smaller than `min_ack_delay`.\r\n\r\nThat contradicts from the practice of the core draft, that restricts the use of FRAME_ENCODING_ERROR to syntactic (i.e. encoding) errors.\r\n\r\nThis PR fixes the problem by changing the error code to be used in that case to PROTOCOL_VIOLATION.\r\n",
      "createdAt": "2020-04-07T04:01:54Z",
      "updatedAt": "2020-04-18T21:03:17Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "a2283352a7314e730d43681fdac31a54cfab2c7e",
      "headRepository": "kazuho/ack-frequency",
      "headRefName": "kazuho/semantic-error-is-not-frame-encoding-error",
      "headRefOid": "c97fff0520df677956dbeb9de9a0f8858b1f5d68",
      "closedAt": "2020-04-18T21:03:17Z",
      "mergedAt": "2020-04-18T21:03:17Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MzgyNjI0",
          "commit": {
            "abbreviatedOid": "c97fff0"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-07T18:29:43Z",
          "updatedAt": "2020-04-07T18:29:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA3OTg3NTEx",
      "title": "Replace 'Ignore Order' with 'Packet Loss Threshold'",
      "url": "https://github.com/quicwg/ack-frequency/pull/36",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #35 by specifying a 'Packet Loss Threshold' field which allows the sender of the frame to communicate the packet loss threshold to the receiver, avoiding unnecessary immediate ACKs and speeding up loss detection.",
      "createdAt": "2020-04-23T15:09:30Z",
      "updatedAt": "2021-09-08T12:12:29Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-packet-loss-threshold",
      "headRefOid": "ec27899e2dd6eca6b474c26d9e989de52f63df63",
      "closedAt": "2021-09-08T12:07:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The direction is to not add this unless there's clear justification of its value, so closing.  Also, it's clear the PR was confusing as written.",
          "createdAt": "2021-09-08T12:12:29Z",
          "updatedAt": "2021-09-08T12:12:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDQ3MzU5",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T05:43:46Z",
          "updatedAt": "2020-08-07T05:43:47Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I don't know how to implement this.  Or maybe it's just a bug.\r\n\r\nLet's say that I acknowledged packet 10.  The packet loss threshold is 4.  As stated, this says: acknowledge immediately if you receive packet 15.  That seems OK.\r\n\r\nBut if I acknowledge 10, but 9 has not been received, this text implies that receiving 13 would cause an immediate ACK.  That seems like it might always result in an immediate ACK over time:\r\n\r\n```\r\nif pn > largest_received:\r\n  largest_received = pn\r\n  for n in 0..(largest_received - loss_threshold):\r\n    if !received(n):\r\n      send_immediate_ack()\r\n      break\r\n```\r\n\r\nIf instead this is something like:\r\n\r\n```\r\nif pn > largest_received:\r\n  largest_received = pn\r\n  if loss_threshold > 0 && largest_received > largest_acked + loss_threshold:\r\n    for n in (largest_acked + 1)..(largest_received - loss_threshold):\r\n      if !received(n):\r\n        send_immediate_ack()\r\n        break\r\n```\r\n\r\nThat might be a reason to include the largest acknowledged in the calculation.\r\n\r\nAssuming the latter is your intent, as this requires iteration over `loss_threshold` packets, receivers should be allowed to limit the size of this value arbitrarily to avoid O(N) work for little attacker cost.",
              "createdAt": "2020-08-07T05:43:46Z",
              "updatedAt": "2020-08-07T05:43:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDg5MTY3",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T07:21:51Z",
          "updatedAt": "2020-08-07T07:21:52Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "FWIW, I tend to think that the latter is the correct thing to do. But at the same time, I would argue against allowing the receiver to set an arbitrary maximum for the loss_threshold field, as that prevents the sender from using a loss_threshold as a way of asking the receiver to ignore order.\r\n\r\nIn practice, I would assume that a receiver would be using a list of ranges (i.e. ack blocks) for representing what needs to be sent in an ACK frame. Typically, the number of blocks will exceed an internal threshold and trigger an ack before the attack being described here becomes an issue. I would be fine with pointing that out explicitly, and that would work as a mitigation.",
              "createdAt": "2020-08-07T07:21:51Z",
              "updatedAt": "2020-08-07T07:21:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMTA5MTIy",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T07:56:07Z",
          "updatedAt": "2020-08-07T07:56:08Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "As a followup to this.  I tried implementing this and realized that if you hold ranges of packets, you can do something sensible without having to limit the value of `loss_threshold`, but it isn't very easy to think about.\r\n\r\nIf you haven't sent an ACK yet, then you can check that the `range.min > 0` and `range.max > loss_threshold`.  This says that the range of unacknowledged packets you have received doesn't start at 0 and there might be more than `loss_threshold` packets outstanding.  This bit gets a little sketchy when people start packet numbers at numbers greater than 0, but I think that the immediate ACK there is tolerable in that case, because it happens just once when it might not be desirable (that is, for the first application data packet).\r\n\r\nIf you have sent an ACK including `largest`, then you check that `range.min > largest + 1` and `range.max > largest + loss_threshold`.\r\n\r\nThis only works if you merge ranges properly when receiving packets.  For instance, when receiving packets 3, 1, and 2 in that order, you produce a single range that covers 1 to 3 and not separate ranges.  Merging ranges is fairly straightforward, and you more or less have to it to construct valid ACK frames, but it's worth noting.\r\n\r\nI ultimately track the *next* packet that needs acknowledgment rather than the largest (this saves errors at 0), and so I get:\r\n\r\n```\r\non_received(pn):\r\n\r\nranges.add(pn)\r\nif pn == ranges.largest().max {\r\n  # this just extended the most recent range\r\n  last_packet_time = now()\r\n  if loss_threshold > 0:\r\n    reordered = next_unacknowledged < ranges.largest().min && pn >= next_unacknowledged + loss_threshold\r\n  else:\r\n    reordered = false\r\nelse:\r\n  reordered = pn < next_unacknowledged\r\nendif\r\n```",
              "createdAt": "2020-08-07T07:56:08Z",
              "updatedAt": "2020-08-07T07:56:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjc3NTc3",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T12:38:41Z",
          "updatedAt": "2020-08-07T12:38:42Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "~~The way I'd solve this is to look up the oldest unacked packet.  This packet would have the smallest packet number.  This is the packet number to subtract from `largest_received`; the difference is to be compared with `loss_threshold`.~~\r\n\r\nEdit: post-coffee I realize that this is not what's intended.",
              "createdAt": "2020-08-07T12:38:42Z",
              "updatedAt": "2020-08-07T12:49:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyODk1NjYy",
      "title": "CE is covered in section 13.2.1 of transport draft",
      "url": "https://github.com/quicwg/ack-frequency/pull/39",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-04T17:12:13Z",
      "updatedAt": "2021-07-12T16:54:42Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d",
      "headRepository": "dtikhonov/ack-frequency",
      "headRefName": "patch-1",
      "headRefOid": "0e333c4e40330d713d0d394210fcbbbd6f32e227",
      "closedAt": "2021-07-12T16:54:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDIxNjY5",
          "commit": {
            "abbreviatedOid": "0e333c4"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-04T17:27:45Z",
          "updatedAt": "2020-08-04T17:27:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MTA3ODM3",
          "commit": {
            "abbreviatedOid": "0e333c4"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-11T07:21:36Z",
          "updatedAt": "2021-01-11T07:21:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzM4MzEy",
          "commit": {
            "abbreviatedOid": "0e333c4"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T16:54:28Z",
          "updatedAt": "2021-07-12T16:54:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MzI2NjY3",
      "title": "Change codepoints to avoid conflict with draft revisions",
      "url": "https://github.com/quicwg/ack-frequency/pull/41",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We don't need to change the frame type on each draft version, but I figured that it'd be safer.",
      "createdAt": "2020-11-02T21:22:40Z",
      "updatedAt": "2020-11-02T23:47:35Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/opcode",
      "headRefOid": "3720428fe2c323fae8715e9fc3afdda3ec974ef5",
      "closedAt": "2020-11-02T23:47:34Z",
      "mergedAt": "2020-11-02T23:47:34Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "35fed220a6b7a52ddcdecab495f902216c7d6969"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1ODQwNDkw",
      "title": "min_ack_delay is a unilateral indication",
      "url": "https://github.com/quicwg/ack-frequency/pull/47",
      "state": "MERGED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #42. Clearly declares that the TP only works in one direction.",
      "createdAt": "2021-03-05T19:56:40Z",
      "updatedAt": "2021-04-19T18:37:46Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "35fed220a6b7a52ddcdecab495f902216c7d6969",
      "headRepository": "nibanks/ack-frequency",
      "headRefName": "patch-1",
      "headRefOid": "31c0570abcdfcf1dce02e2c1b2c5f20e1d3429e4",
      "closedAt": "2021-04-19T18:37:46Z",
      "mergedAt": "2021-04-19T18:37:46Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5e83cc8190b4eccea997fc7d1ddfd7520240533c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTkzMzM3",
          "commit": {
            "abbreviatedOid": "053d1bb"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-05T20:58:22Z",
          "updatedAt": "2021-03-05T20:58:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'd drop this sentence, since it's not quite saying what you want to say at the moment and I think the paragraph works without it.\r\n\r\n```suggestion\r\nreceiving ACK_FREQUENCY frames.  If an endpoint sends the transport parameter, the peer\r\n```",
              "createdAt": "2021-03-05T20:58:22Z",
              "updatedAt": "2021-03-05T21:01:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjEzMDky",
          "commit": {
            "abbreviatedOid": "31c0570"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-15T23:22:28Z",
          "updatedAt": "2021-04-15T23:22:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcwNzkwMDE0",
      "title": "Change title, fix refs",
      "url": "https://github.com/quicwg/ack-frequency/pull/50",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-15T22:16:59Z",
      "updatedAt": "2021-06-15T22:44:27Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "f97243281aa4a399bc43018c52288bee8cb7e9f6",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/title",
      "headRefOid": "cccc4c71cdccd947aa725d1a662a22bc1e056b74",
      "closedAt": "2021-06-15T22:41:51Z",
      "mergedAt": "2021-06-15T22:41:51Z",
      "mergedBy": "mjoras",
      "mergeCommit": {
        "oid": "43953203d3a285090f1922c1554a9fce1312e620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NTM5MDE0",
          "commit": {
            "abbreviatedOid": "80450a2"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-15T22:17:48Z",
          "updatedAt": "2021-06-15T22:17:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NTUyMjgw",
          "commit": {
            "abbreviatedOid": "cccc4c7"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T22:44:26Z",
          "updatedAt": "2021-06-15T22:44:27Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\ndocname: draft-ietf-quic-ack-frequency-latest\r\n```",
              "createdAt": "2021-06-15T22:44:26Z",
              "updatedAt": "2021-06-15T22:44:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc4OTM4NDc5",
      "title": "fixup links to repo and list",
      "url": "https://github.com/quicwg/ack-frequency/pull/52",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-28T10:58:51Z",
      "updatedAt": "2021-06-28T16:41:40Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "0ac7e5e950b5d705ee9f89d9ea8c0d2056a3fd3e",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "lucas/fixup-discussion-links",
      "headRefOid": "67d85a6502acfa9df7b34faadc5e60a152add0e9",
      "closedAt": "2021-06-28T16:41:40Z",
      "mergedAt": "2021-06-28T16:41:40Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "cacf0485084e3638dcb0fcf805d06a55a3dd248a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0MTcwNTk0",
          "commit": {
            "abbreviatedOid": "67d85a6"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-28T16:41:36Z",
          "updatedAt": "2021-06-28T16:41:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4MDA2Mjc4",
      "title": "Fix CE section reference",
      "url": "https://github.com/quicwg/ack-frequency/pull/54",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Copy of #39, applied to new draft filename.\r\nCloses #39.",
      "createdAt": "2021-07-12T16:54:18Z",
      "updatedAt": "2021-07-12T16:54:42Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "cacf0485084e3638dcb0fcf805d06a55a3dd248a",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "fixsection",
      "headRefOid": "f2ac9f2ec0e3ce17712a9d3f992608cd1df2ad00",
      "closedAt": "2021-07-12T16:54:42Z",
      "mergedAt": "2021-07-12T16:54:42Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "18b674861d099a9053919c7c1543e5eccee0c6df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzM4NDQ3",
          "commit": {
            "abbreviatedOid": "f2ac9f2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T16:54:36Z",
          "updatedAt": "2021-07-12T16:54:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4MDIwOTU2",
      "title": "Rename 'Packet Tolerance' to 'ACK-Eliciting Threshold'",
      "url": "https://github.com/quicwg/ack-frequency/pull/55",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Part of #27\r\n\r\nWe still need to decide whether to change 'Update Max Ack Delay' to 'Max Ack Delay'.",
      "createdAt": "2021-07-12T17:13:43Z",
      "updatedAt": "2021-07-29T14:39:24Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "e5b46f2888aa5dc87daac3a430b5d4c832d5dd9a",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-ack-eliciting-threshold",
      "headRefOid": "d2a84dcf14dfe1884ae92d8c6af83b27ad299436",
      "closedAt": "2021-07-29T14:39:24Z",
      "mergedAt": "2021-07-29T14:39:24Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "a458009b1828cf719b2c5499e72b419956f65a0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0Mzg1ODI1",
          "commit": {
            "abbreviatedOid": "aeb4036"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T17:48:21Z",
          "updatedAt": "2021-07-12T17:49:21Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n|                  Ack-Eliciting Threshold (i)                ...\r\n```",
              "createdAt": "2021-07-12T17:48:21Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nAck-Eliciting Threshold:\r\n```",
              "createdAt": "2021-07-12T17:48:33Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nis recorded as the largest seen sequence number. The new Ack-Eliciting Threshold\r\n```",
              "createdAt": "2021-07-12T17:48:44Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nand `Ack-Eliciting Threshold` values ({{multiple-frames}}), the endpoint MUST send an\r\n```",
              "createdAt": "2021-07-12T17:48:53Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\n  packets is greater than or equal to the recorded `Ack-Eliciting Threshold`.\r\n```",
              "createdAt": "2021-07-12T17:49:02Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n`Ack-Eliciting Threshold` and `max_ack_delay` thresholds for sending\r\n```",
              "createdAt": "2021-07-12T17:49:12Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDU4Nzc5",
      "title": "Change Update Max Ack Delay to Request Max Ack Delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/56",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes the remainder of #27 not fixed by #55",
      "createdAt": "2021-07-22T19:58:27Z",
      "updatedAt": "2021-09-09T23:55:36Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "b8a834e72d9d14aa366e81fe5f9ddedd4bf73eb2",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-request-max-ack-delay",
      "headRefOid": "5520d9fa7d2e35d7c83115097f52009447a1f9b7",
      "closedAt": "2021-09-09T23:55:36Z",
      "mergedAt": "2021-09-09T23:55:36Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "2d9681036b0c69cc08c050604e81863cc14d0df2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDE3Njcz",
          "commit": {
            "abbreviatedOid": "adb702e"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "One suggestion, but looks good to me otherwise.",
          "createdAt": "2021-07-23T18:11:23Z",
          "updatedAt": "2021-07-23T18:30:06Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Suggestion: \"A variable-length integer representing the value to which the endpoint requests the peer to update its `max_ack_delay` (Section 18.2 of {{QUIC-TRANSPORT}}).\"",
              "createdAt": "2021-07-23T18:29:08Z",
              "updatedAt": "2021-07-23T18:30:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4NTEx",
          "commit": {
            "abbreviatedOid": "adb702e"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:48:12Z",
          "updatedAt": "2021-07-24T11:48:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI5Njgz",
          "commit": {
            "abbreviatedOid": "adb702e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-24T12:07:25Z",
          "updatedAt": "2021-07-24T12:07:25Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I went with your suggestion with one less 'to'. It's definitely more correct, but I'd like to find something easier to read.\r\n\r\nI came up with the following, but I'm not sure it's better:\r\n\"A variable-length integer representing the updated max_ack_delay (Section 18.2 of {{QUIC-TRANSPORT}}) value the endpoint is requesting of the peer.\"",
              "createdAt": "2021-07-24T12:07:25Z",
              "updatedAt": "2021-07-24T12:07:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTA0NTI5",
          "commit": {
            "abbreviatedOid": "92f1388"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is good enough. You have a conflict to resolve, but let's merge this.",
          "createdAt": "2021-09-09T22:43:46Z",
          "updatedAt": "2021-09-09T22:43:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDc1OTY3",
      "title": "Set limits to min_ack_delay and max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/57",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #43.\r\nCloses #44.",
      "createdAt": "2021-07-22T20:25:01Z",
      "updatedAt": "2021-07-31T01:15:52Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "89980ef76468ce41df2e11cbc6244eb0f7a78753",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/min-max",
      "headRefOid": "8a87dbd3d38c40507a2ca346f242fbdee3866ec3",
      "closedAt": "2021-07-31T01:15:52Z",
      "mergedAt": "2021-07-31T01:15:51Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "b8a834e72d9d14aa366e81fe5f9ddedd4bf73eb2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzMzI1NjAy",
          "commit": {
            "abbreviatedOid": "8a87dbd"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T00:16:42Z",
          "updatedAt": "2021-07-23T00:16:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzNzgyNTMz",
          "commit": {
            "abbreviatedOid": "8a87dbd"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T14:25:17Z",
          "updatedAt": "2021-07-23T14:25:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4NDU0",
          "commit": {
            "abbreviatedOid": "8a87dbd"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:47:01Z",
          "updatedAt": "2021-07-24T11:47:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NTk3MzE2",
      "title": "Tweak ack-eliciting threshold.",
      "url": "https://github.com/quicwg/ack-frequency/pull/58",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #49\r\n\r\nAlso updates the transport parameter codepoint to 0xff03de1a from 0xff02de1a.",
      "createdAt": "2021-07-23T00:45:44Z",
      "updatedAt": "2021-09-10T00:24:46Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "2d9681036b0c69cc08c050604e81863cc14d0df2",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-tweak-ack-threshold",
      "headRefOid": "4311a922f4c2d79e25bd37aaa27d80638fa56eec",
      "closedAt": "2021-09-10T00:24:46Z",
      "mergedAt": "2021-09-10T00:24:45Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "71ec632906f12388cf6623399d3deac3c2d59585"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzNzgxMTEw",
          "commit": {
            "abbreviatedOid": "0b83fda"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T14:24:04Z",
          "updatedAt": "2021-07-23T14:24:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I believe you are missing a word (`packets`?) between `ack-eliciting` and `you can`.",
              "createdAt": "2021-07-23T14:24:04Z",
              "updatedAt": "2021-07-23T14:24:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzODQ3NTEx",
          "commit": {
            "abbreviatedOid": "0b83fda"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T15:31:43Z",
          "updatedAt": "2021-07-23T15:31:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yes, thanks.",
              "createdAt": "2021-07-23T15:31:43Z",
              "updatedAt": "2021-07-23T15:31:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzODUwNDUw",
          "commit": {
            "abbreviatedOid": "1ce9b5f"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T15:34:49Z",
          "updatedAt": "2021-07-23T15:34:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDMxODQy",
          "commit": {
            "abbreviatedOid": "f92fbf5"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T18:31:12Z",
          "updatedAt": "2021-07-23T19:01:10Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nmin_ack_delay (0xff03de1a):\r\n```",
              "createdAt": "2021-07-23T18:31:12Z",
              "updatedAt": "2021-07-23T19:01:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjE0NDYz",
          "commit": {
            "abbreviatedOid": "f92fbf5"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-24T07:41:53Z",
          "updatedAt": "2021-07-24T07:41:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nmin_ack_delay (0x9a7eb021):\r\n```\r\n\r\nGenerating a fresh value is a) good hygiene, b) easy.",
              "createdAt": "2021-07-24T07:41:54Z",
              "updatedAt": "2021-07-24T07:41:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjE0NTI3",
          "commit": {
            "abbreviatedOid": "f92fbf5"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-24T07:42:58Z",
          "updatedAt": "2021-07-24T07:42:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"you\"?\r\n\r\nThis is the maximum number of ack-eliciting packets that the recipient of this frame can receive without sending an immediate acknowledgment.",
              "createdAt": "2021-07-24T07:42:58Z",
              "updatedAt": "2021-07-24T07:42:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0NjkyMjM3",
          "commit": {
            "abbreviatedOid": "d1f68ef"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-26T10:35:42Z",
          "updatedAt": "2021-07-26T10:35:42Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I took Jana's suggestion, but don't have a strong opinion between similar codepoints and random ones.",
              "createdAt": "2021-07-26T10:35:42Z",
              "updatedAt": "2021-07-26T10:35:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0NjkzNTEy",
          "commit": {
            "abbreviatedOid": "d1f68ef"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-26T10:37:21Z",
          "updatedAt": "2021-07-26T10:37:21Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks",
              "createdAt": "2021-07-26T10:37:21Z",
              "updatedAt": "2021-07-26T10:37:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzQ0MTcw",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T20:23:50Z",
          "updatedAt": "2021-07-27T20:23:51Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Is there a way to phrase this such that the off-by-one-ness is intuitive?\r\nSomething along the lines of \"the number of packets after the most-recently-acked one to skip before sending another ack\".\r\n\r\nSo saying \"skip zero packets\" means ack every time, saying \"skip one packet after the most recently acked one\" means ack every-other. \r\n\r\nStill trying to come up with a nice way to word that, but it seems like it could reduce off-by-one confusion.",
              "createdAt": "2021-07-27T20:23:50Z",
              "updatedAt": "2021-07-27T20:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzY0ODAz",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T20:48:57Z",
          "updatedAt": "2021-07-27T20:48:57Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I'm definitely open to other wordings.  I think the example of 0 helps for me, but suggestions are welcome.",
              "createdAt": "2021-07-27T20:48:57Z",
              "updatedAt": "2021-07-27T20:48:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2Mzg3ODAy",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T21:18:22Z",
          "updatedAt": "2021-07-27T21:18:22Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The phrasing I used was \"the number of packets you can receive without sending an immediate acknowledgment\". So has Ian. Isn't that intuitive enough?",
              "createdAt": "2021-07-27T21:18:22Z",
              "updatedAt": "2021-07-27T21:19:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTA2ODUz",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T22:48:33Z",
          "updatedAt": "2021-09-09T22:55:55Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n  packets the recipient of this frame can receive without sending an immediate\r\n```",
              "createdAt": "2021-09-09T22:48:33Z",
              "updatedAt": "2021-09-09T22:55:55Z"
            },
            {
              "originalPosition": 19,
              "body": "The text is slightly but enough different to the suggestion you made, @martinthomson. I think we should replace \"before\" with \"without\".",
              "createdAt": "2021-09-09T22:48:38Z",
              "updatedAt": "2021-09-09T22:55:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MTA5Njg3",
      "title": "Cap ACK-eliciting threshold if the received value is too large",
      "url": "https://github.com/quicwg/ack-frequency/pull/59",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #45",
      "createdAt": "2021-07-23T17:35:14Z",
      "updatedAt": "2021-07-31T01:13:42Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "89980ef76468ce41df2e11cbc6244eb0f7a78753",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-cap-ack-eliciting-threshold",
      "headRefOid": "4e904ce9048a34c6a33a15b86e033fa83615ef4d",
      "closedAt": "2021-07-31T01:13:42Z",
      "mergedAt": "2021-07-31T01:13:42Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "88d9c0bf8298d3c7ba02556a0ffa4870c2652532"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzOTY0NTEx",
          "commit": {
            "abbreviatedOid": "7fb52e4"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T17:37:13Z",
          "updatedAt": "2021-07-23T17:37:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDkzMzgy",
          "commit": {
            "abbreviatedOid": "7fb52e4"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T20:07:55Z",
          "updatedAt": "2021-07-23T20:07:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4MDk4",
          "commit": {
            "abbreviatedOid": "7fb52e4"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:40:16Z",
          "updatedAt": "2021-07-24T11:40:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "The largest representable value is by definition the maximum value.\r\n```suggestion\r\n  value instead.\r\n```",
              "createdAt": "2021-07-24T11:40:16Z",
              "updatedAt": "2021-07-24T11:40:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MTE2ODIy",
      "title": "MAY omit the max_ack_delay if enough packets are in flight",
      "url": "https://github.com/quicwg/ack-frequency/pull/60",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #37 by allowing implementations to not add max_ack_delay to the PTO calculation if enough ack-eliciting packets are in flight.",
      "createdAt": "2021-07-23T17:49:54Z",
      "updatedAt": "2021-09-10T07:15:35Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "89980ef76468ce41df2e11cbc6244eb0f7a78753",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-omit-max-ack-delay",
      "headRefOid": "cda2f6719c14f81ad3ac09937435f8b2dc57648e",
      "closedAt": "2021-09-10T07:15:35Z",
      "mergedAt": "2021-09-10T07:15:35Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5aeebefc3a0e33d69b5b830663f2fa7c78368299"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann Does Jana's longer explanation help or would you like more clarification?",
          "createdAt": "2021-07-27T00:08:37Z",
          "updatedAt": "2021-07-27T00:08:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDk3MDg0",
          "commit": {
            "abbreviatedOid": "694afdd"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T20:14:01Z",
          "updatedAt": "2021-07-23T20:14:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nACK-Eliciting Threshold, an endpoint can expect that the peer\r\nwill not need to wait for its `max_ack_delay` period before\r\nsending an acknowledgement. In such cases, the endpoint MAY\r\ntherefore exclude the peer's 'max_ack_delay' from its PTO\r\ncalculation.\r\n```",
              "createdAt": "2021-07-23T20:14:01Z",
              "updatedAt": "2021-07-23T20:14:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4MjY4",
          "commit": {
            "abbreviatedOid": "694afdd"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm not sure I understand the motivation for this (I'm also having trouble following the issue). Can we add some more explanation here?",
          "createdAt": "2021-07-24T11:43:01Z",
          "updatedAt": "2021-07-24T11:43:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1ODE4NjIw",
          "commit": {
            "abbreviatedOid": "e053319"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-27T11:55:20Z",
          "updatedAt": "2021-07-27T11:55:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTgyNDU5",
          "commit": {
            "abbreviatedOid": "e053319"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "one suggestion, but lgtm otherwise.",
          "createdAt": "2021-09-10T01:52:20Z",
          "updatedAt": "2021-09-10T01:52:39Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\ncalculation. Note that this optimization requires some care in implementation, since\r\nit can cause premature PTOs under packet loss when `ignore_order` is enabled.\r\n```",
              "createdAt": "2021-09-10T01:52:20Z",
              "updatedAt": "2021-09-10T01:52:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MTk2NTU4",
      "title": "Don't change ack behavior until ACK_FREQUENCY is received",
      "url": "https://github.com/quicwg/ack-frequency/pull/61",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #25.",
      "createdAt": "2021-07-23T20:34:18Z",
      "updatedAt": "2021-09-10T16:23:50Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "fae9484977b8bb16ead9bcace6e81727d5051571",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/tp-only",
      "headRefOid": "810155d0d1be47d8abb0acc91daa237f56a444a1",
      "closedAt": "2021-09-10T16:23:50Z",
      "mergedAt": "2021-09-10T16:23:50Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "eccfdbe87babccd5294d3264c7627de0f5b08091"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MTA5NzIw",
          "commit": {
            "abbreviatedOid": "c68c59d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T20:35:55Z",
          "updatedAt": "2021-07-23T20:35:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nreceiving this transport parameter does not cause the endpoint to\r\n```",
              "createdAt": "2021-07-23T20:35:55Z",
              "updatedAt": "2021-07-23T20:35:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MTE4OTg2",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T20:52:36Z",
          "updatedAt": "2021-07-23T20:52:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI3OTc3",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:38:02Z",
          "updatedAt": "2021-07-24T11:38:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4MzIw",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:44:01Z",
          "updatedAt": "2021-07-24T11:44:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjUyMDEz",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Works for me.",
          "createdAt": "2021-07-24T18:17:31Z",
          "updatedAt": "2021-07-24T18:17:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAwNjMxNTUz",
      "title": "MUST NOT store min_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/63",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Closes #22 and #40\r\n\r\nAnd by implication, cannot send ACK_FREQUENCY in 0-RTT packets.",
      "createdAt": "2021-07-31T01:10:21Z",
      "updatedAt": "2021-09-10T16:15:48Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "a458009b1828cf719b2c5499e72b419956f65a0b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-dont-store-min-ack-delay",
      "headRefOid": "c0084a4105c45d36a77f0eab46a8432e6eb0d35f",
      "closedAt": "2021-09-10T16:15:48Z",
      "mergedAt": "2021-09-10T16:15:48Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "fae9484977b8bb16ead9bcace6e81727d5051571"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NjEwMDU2",
          "commit": {
            "abbreviatedOid": "5e664b1"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T23:49:14Z",
          "updatedAt": "2021-07-31T23:49:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Please drop this last sentence.",
              "createdAt": "2021-07-31T23:49:15Z",
              "updatedAt": "2021-07-31T23:49:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwMjEyNzU1",
          "commit": {
            "abbreviatedOid": "5e664b1"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thank you for the PR. Looks good, below is nothing more than an editorial preference.",
          "createdAt": "2021-08-02T13:38:08Z",
          "updatedAt": "2021-08-02T13:39:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "How about going like:\r\n```suggestion\r\nEndpoints MUST NOT remember the value of min_ack_delay transport parameter they received.\r\n```\r\n\r\nI think provision of the first sentence (\"An endpoint MUST NOT send ACK_FREQUENCY frames until ...\") is covered by the last sentence of the previous paragraph. If we think that that sentence is vague, we can change \"if\" of that sentence to \"if and only if.\"\r\n\r\nRegarding the second sentence, my preference goes to using the phrase \"remembered\" and talking about both sides, because that is what RFC 9000 does.",
              "createdAt": "2021-08-02T13:38:08Z",
              "updatedAt": "2021-08-02T13:39:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNzI2MjU3",
          "commit": {
            "abbreviatedOid": "e5e173c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T02:27:14Z",
          "updatedAt": "2021-08-03T02:27:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I took Kazuho's suggestion, which I think is correct based on the discussion on #22?",
              "createdAt": "2021-08-03T02:27:14Z",
              "updatedAt": "2021-08-03T02:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNzI2NTUx",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T02:28:00Z",
          "updatedAt": "2021-08-03T02:28:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks, suggestion accepted.",
              "createdAt": "2021-08-03T02:28:00Z",
              "updatedAt": "2021-08-03T02:28:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxMTIxMzQz",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-03T12:14:00Z",
          "updatedAt": "2021-08-03T12:14:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNzM4MTk2",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-04T00:06:11Z",
          "updatedAt": "2021-08-04T00:06:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTg0MTY2",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "couple of suggestions, but lgtm",
          "createdAt": "2021-09-10T01:56:51Z",
          "updatedAt": "2021-09-10T01:59:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nthey received. Consequently, ACK_FREQUENCY frames MUST NOT be sent in 0-RTT\r\n```",
              "createdAt": "2021-09-10T01:56:51Z",
              "updatedAt": "2021-09-10T01:59:38Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\npackets, as per Section 7.4.1 of {{QUIC-TRANSPORT}}.\r\n```",
              "createdAt": "2021-09-10T01:59:18Z",
              "updatedAt": "2021-09-10T01:59:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTg3MTkw",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-10T02:05:07Z",
          "updatedAt": "2021-09-10T02:05:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "isn't it \"cannot\"?\r\n\r\n(You see, if we say \"MUST NOT\", we probably need to say what happens if you get a 0-RTT packet with ACK_FREQUENCY in it, but I know that some implementations can't really make that distinction.)",
              "createdAt": "2021-09-10T02:05:07Z",
              "updatedAt": "2021-09-10T02:05:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxMTEwODIz",
          "commit": {
            "abbreviatedOid": "983de2c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-10T07:13:05Z",
          "updatedAt": "2021-09-10T07:13:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good point, I think cannot is more correct, updated.",
              "createdAt": "2021-09-10T07:13:05Z",
              "updatedAt": "2021-09-10T07:13:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxMzQ0Mjk4",
          "commit": {
            "abbreviatedOid": "c0084a4"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-10T12:13:42Z",
          "updatedAt": "2021-09-10T12:13:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI5NjAyNTY3",
      "title": "Add an IMMEDIATE_ACK frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/64",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #34 by adding a one byte IMMEDIATE_ACK frame.",
      "createdAt": "2021-09-08T12:30:33Z",
      "updatedAt": "2021-09-15T23:28:30Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "b8a834e72d9d14aa366e81fe5f9ddedd4bf73eb2",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-immediate-ack",
      "headRefOid": "e81e1ad5374acb94d239aca590feb2d9b65511bb",
      "closedAt": "2021-09-15T23:28:30Z",
      "mergedAt": "2021-09-15T23:28:30Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "2653d744076e98d40bf0b6240d82af2e84f0a2c9"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "editorial nit: my preference would be for frame diagrams to use the notation in QUIC transport. I see that ACK_FREQUENCY is defined using ASCII art, so perhaps you want to consider a separate follow up PR to switch styles after this lands.",
          "createdAt": "2021-09-08T12:35:12Z",
          "updatedAt": "2021-09-08T12:35:12Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Lucas, I filed #66 to update them.",
          "createdAt": "2021-09-08T15:50:21Z",
          "updatedAt": "2021-09-08T15:50:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxMzQ0OTc4",
          "commit": {
            "abbreviatedOid": "2235bf4"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-10T12:14:36Z",
          "updatedAt": "2021-09-10T12:14:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4s5865",
          "commit": {
            "abbreviatedOid": "5de6302"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-14T01:33:19Z",
          "updatedAt": "2021-09-14T01:33:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxODk5MjAy",
      "title": "Add a DELAY_ACK frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/67",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "This frame overrides the behavior of IMMEDIATE_ACK, if the two were to be placed in the same packet.  This would of course be silly, but I don't think it's worth disallowing given the lack of harm.\r\n\r\nFixes #65",
      "createdAt": "2021-09-11T08:51:21Z",
      "updatedAt": "2021-09-15T20:03:54Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "eccfdbe87babccd5294d3264c7627de0f5b08091",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-no-ack",
      "headRefOid": "e25e0d9a8ce01e74404628da8229162e1507aa5d",
      "closedAt": "2021-09-15T20:03:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "1) Do we really need this?\r\n2) What happens if the receiver ignores the frame and just acks the packet?\r\n3) If a packet contains both immediate_ack and no_ack, the reaction should be \"protocol error\", not \"ignore one and pick the other\".",
          "createdAt": "2021-09-13T00:18:30Z",
          "updatedAt": "2021-09-13T00:18:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4s6Jqd",
          "commit": {
            "abbreviatedOid": "e25e0d9"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Still not supportive of doing this.  See list discussion.",
          "createdAt": "2021-09-14T03:38:42Z",
          "updatedAt": "2021-09-14T03:40:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Missing negation?",
              "createdAt": "2021-09-14T03:38:43Z",
              "updatedAt": "2021-09-14T03:40:25Z"
            },
            {
              "originalPosition": 4,
              "body": "The ordering of this section is a bit off.  This concept is less important than ACK_FREQUENCY, so it should probably go after it.\r\n\r\nThis frame needs citations from other parts of the document.",
              "createdAt": "2021-09-14T03:39:47Z",
              "updatedAt": "2021-09-14T03:51:59Z"
            },
            {
              "originalPosition": 11,
              "body": "Section reference for IMMEDIATE_ACK?",
              "createdAt": "2021-09-14T03:40:09Z",
              "updatedAt": "2021-09-14T03:40:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxOTk2MjQ2",
      "title": "ACK less frequently when CE marks are received",
      "url": "https://github.com/quicwg/ack-frequency/pull/68",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Per @bbriscoe's suggestion in #48, this PR changes the immediate ACK behavior to only send an immediate ACK when transitioning from non-marked to CE marked.\r\n\r\nAlso treats receipt of non Ack-Eliciting packets as Ack-Eliciting if they are CE marked.\r\n\r\nFixes #48",
      "createdAt": "2021-09-11T20:14:21Z",
      "updatedAt": "2021-10-13T09:59:27Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "2172c24df098c408456f2f30bba56ba3bf27e2b1",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-ce-immediate-ack",
      "headRefOid": "c0f542e96584522bf9d401447eb15c0a42090bd6",
      "closedAt": "2021-10-12T20:39:58Z",
      "mergedAt": "2021-10-12T20:39:57Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "1fcf6a17e8f9bbfb3a51e9d6f02046bb3401ef5b"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm wondering if this should be max(2, Ack-Eliciting Threshold)/2 instead?\r\n\r\nAs it is, except for the immediate ack on unmarked to CE marked, this algorithm basically doesn't change acknowledgement behavior at all.",
          "createdAt": "2021-09-12T13:19:24Z",
          "updatedAt": "2021-09-12T13:19:24Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is about done and I'd like to merge it prior to shipping the next version of the draft.  Can anyone provide a final review?",
          "createdAt": "2021-10-10T15:10:29Z",
          "updatedAt": "2021-10-10T15:10:29Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett and I discussed this. Forcing ACKing of ACKs seems problematic (thanks @kazuho), and we would like to steer clear of that for this time being. So we are removing any text about ACKing non-ack-eliciting packets, since that seems like a footgun. If there's a specific reason to include it, let's do that in a new Issue and PR.",
          "createdAt": "2021-10-12T20:38:29Z",
          "updatedAt": "2021-10-12T20:38:29Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the suggestion @kazuho Let's keep this relatively simple for now.",
          "createdAt": "2021-10-13T09:59:27Z",
          "updatedAt": "2021-10-13T09:59:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyMjI4ODU3",
          "commit": {
            "abbreviatedOid": "b44b55d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-12T23:47:57Z",
          "updatedAt": "2021-09-12T23:50:48Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nAn endpoint SHOULD send an immediate acknowledgement when a packet marked\r\n```",
              "createdAt": "2021-09-12T23:47:57Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nreceived and the previous packet was not marked CE.\r\n```",
              "createdAt": "2021-09-12T23:48:34Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ncompared to {{Section 13.2.1 of QUIC-TRANSPORT}} when peers are using\r\n```",
              "createdAt": "2021-09-12T23:49:14Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            },
            {
              "originalPosition": 14,
              "body": "How about\r\n> An endpoint SHOULD reduce its Ack-Eliciting Threshold to at most 2 when acknowledging a contiguous series of CE marked packets.",
              "createdAt": "2021-09-12T23:50:42Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyMjMyNDA2",
          "commit": {
            "abbreviatedOid": "b44b55d"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-13T00:13:10Z",
          "updatedAt": "2021-09-13T00:13:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This line is a bit confusing. I think we can separate out `reduces the peer's response time to congestion events` and `while also reducing the ACK rate as compared to`. Another clarification is needed about the fact that congestion controllers don't mark but respond to marks.\r\nSuggestion:\r\n```\r\nDoing so reduces the peer's response time to congestion events especially when peers are using DCTCP {{?RFC8257}} or other congestion controllers that respond to immediate CE markings which are much more\r\n frequent than classic ECN {{?RFC3168}}.\r\n ```\r\n And then talk about\r\n ```\r\n This will also help in reducing the ACK rate on the reverse path as compared to Section 13.2.1 of {{QUIC-TRANSPORT}}\r\n ```\r\n \r\n",
              "createdAt": "2021-09-13T00:13:10Z",
              "updatedAt": "2021-09-13T00:13:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4s54JG",
          "commit": {
            "abbreviatedOid": "4b13883"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T00:43:04Z",
          "updatedAt": "2021-09-14T00:43:04Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "It doesn't actually reduce the response time compared to RFC9000, so I think the current text is more accurate?",
              "createdAt": "2021-09-14T00:43:04Z",
              "updatedAt": "2021-09-14T00:43:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4s6Zq7",
          "commit": {
            "abbreviatedOid": "4b13883"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T06:06:38Z",
          "updatedAt": "2021-09-14T06:06:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I copied the `reduces response time` phrase from the current text.\r\nI agree that it doesn't reduce peer's response time to congestion necessarily but makes the response based on the extent of congestion (number of CE marks) instead of its presence. (RFC 9000)\r\n",
              "createdAt": "2021-09-14T06:06:38Z",
              "updatedAt": "2021-09-14T06:06:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4s7tiv",
          "commit": {
            "abbreviatedOid": "4b13883"
          },
          "author": "bbriscoe",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T12:05:50Z",
          "updatedAt": "2021-09-14T12:05:50Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think the original attempt to emulate Accurate ECN feedback in TCP might have been misguided. The AccECN machinery was necessary in TCP because TCP does _not_ have ACK frequency control. Here in QUIC we are adding ACK frequency control. So the only addition needed for ECN should indeed be to immediately trigger an ACK on a transition from non-CE to CE marking. Then, QUIC should just continue ACKing every Ack-Eliciting Threshold packets. No need for the max(2, ...). I think (I'm not working on QUIC, so I don't keep the whole of the QUIC design in my working memory).\r\n\r\nThat sorts out the lower bound on ACK frequency, but it leaves one problem at the upper bound (if I understand QUIC correctly). [RFC9000 \u00a713.2.1.  Sending ACK Frames](https://datatracker.ietf.org/doc/html/rfc9000#section-13.2.1) and [\u00a713.2.4. Limiting Ranges by Tracking ACK Frames](https://datatracker.ietf.org/doc/html/rfc9000#section-13.2.4) suggest that a host that is only sending non-ack-eliciting packets could occasionally include an ack-eliciting packet (e.g. a ping) to catch up on the feedback and allow the other end to clear out the state its been collecting.\r\n\r\nAn example where this could be a problem is when data transfer switches back and forth from one QUIC peer to the other. Imagine an asymmetric data transfer from A to B ends. If the network CE-marked many or all the ACKs on the reverse path (B-A), I believe A will not ACK any of the last round of ACKs it receives. Then if B becomes the sender of a volley of data, it will unknowingly send data into a path that was already congested just with ACKs.\r\n\r\nWith ECN, I'm not sure it's the best design to rely on the sender of the non-ack-eliciting packets (B in the example) to send an occasional ack-eliciting packet. If the receiver of the non-ack-eliciting packets (A) is seeing a large amount of ECN marks, it ought to be able to send occasional ACKs of non-ack-eliciting packets (to B), whether or not B asks for them.\r\n\r\nIn AccECN, we allowed TCP to ack a sequence of CE-marked ACKs, as long as the ACK frequency was no less than 1 per 3 CE-marked packets. Even with 100% CE-marking, this damps any potential ACK ping-pong but still ensures the other end receive feedback of congestion events.\r\n",
              "createdAt": "2021-09-14T12:05:50Z",
              "updatedAt": "2021-09-14T12:05:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4s7xXI",
          "commit": {
            "abbreviatedOid": "4b13883"
          },
          "author": "bbriscoe",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T12:21:20Z",
          "updatedAt": "2021-09-14T12:21:20Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This phrase is not right: \r\n`especially when peers are using DCTCP {{?RFC8257}} or other congestion controllers that respond to immediate CE markings which are much more frequent than classic ECN {{?RFC3168}}.`\r\nFor a start all controllers _respond_ to more frequent CE markings, it's ones that _cause_ more frequent markings. But it's also for during extremes of congestion on the reverse path, irrespective of the type of controller. How about:\r\n`especially during periods of extreme congestion on the reverse path, or when peers are using DCTCP {{?RFC8257}} or other congestion controllers that routinely cause more frequent ECN marking than classic ECN {{?RFC3168}}.`",
              "createdAt": "2021-09-14T12:21:20Z",
              "updatedAt": "2021-09-14T12:21:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tCPFu",
          "commit": {
            "abbreviatedOid": "2a861ba"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-15T19:53:14Z",
          "updatedAt": "2021-09-15T19:53:14Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The PR had already been updated to be more similar to your text, but I added 'extreme congestion', PTAL",
              "createdAt": "2021-09-15T19:53:14Z",
              "updatedAt": "2021-09-15T19:53:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tCPjB",
          "commit": {
            "abbreviatedOid": "2a861ba"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-15T19:55:30Z",
          "updatedAt": "2021-09-15T19:55:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Thanks, I'll update this to make it so CE marked packets are treated like ack-eliciting packets from an ACK perspective, which I think solves the upper bound problem you're outlining?",
              "createdAt": "2021-09-15T19:55:30Z",
              "updatedAt": "2021-09-15T19:55:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tER4E",
          "commit": {
            "abbreviatedOid": "da28352"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T09:53:58Z",
          "updatedAt": "2021-09-16T09:53:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nreceived and the previously received packet was not marked CE.\r\n```",
              "createdAt": "2021-09-16T09:53:58Z",
              "updatedAt": "2021-09-16T09:53:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tESFy",
          "commit": {
            "abbreviatedOid": "da28352"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T09:54:55Z",
          "updatedAt": "2021-09-16T09:54:56Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nAn endpount SHOULD also acknowledge packets received with a CE mark as though\r\n```",
              "createdAt": "2021-09-16T09:54:55Z",
              "updatedAt": "2021-09-16T09:54:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tESOd",
          "commit": {
            "abbreviatedOid": "9cfd170"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T09:55:32Z",
          "updatedAt": "2021-09-16T09:55:32Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nfeedback on CE is received in a timely manner when most packets are\r\nnot ack-eliciting.\r\n```",
              "createdAt": "2021-09-16T09:55:32Z",
              "updatedAt": "2021-09-16T09:55:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tESeg",
          "commit": {
            "abbreviatedOid": "b807548"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T09:56:33Z",
          "updatedAt": "2021-09-16T09:56:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\ncongestion controllers that mark much more frequently than classic ECN {{?RFC3168}}.\r\n```",
              "createdAt": "2021-09-16T09:56:34Z",
              "updatedAt": "2021-09-16T09:56:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uPBer",
          "commit": {
            "abbreviatedOid": "bd938a5"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-10T16:43:10Z",
          "updatedAt": "2021-10-10T16:44:18Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nAn endpoint SHOULD also acknowledge packets received with a CE mark as though\r\n```",
              "createdAt": "2021-10-10T16:43:10Z",
              "updatedAt": "2021-10-10T16:44:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uPJ-9",
          "commit": {
            "abbreviatedOid": "f8aa220"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-10T23:32:55Z",
          "updatedAt": "2021-10-10T23:32:55Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Please disregard this comment if I'm missing some context, but I'm not sure how doing such thing is going to help.\r\n\r\nIIUC, while it is true that sending an immediate ACK for a CE-marked non-ack-eliciting packet (i.e. packet carrying an ACK) might help the _delivery_ of the signal, doing so does not mitigate the congestion. That is because the receiving such an ACK does not reduce the rate at which endpoints send data.\r\n\r\nTherefore, the only outcome of having this requirement would be increased number of packets, even if we disregard the chance of seeing ping-pong. I'm not sure if that's necessary.",
              "createdAt": "2021-10-10T23:32:55Z",
              "updatedAt": "2021-10-10T23:33:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uPKPQ",
          "commit": {
            "abbreviatedOid": "f8aa220"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-10T23:41:37Z",
          "updatedAt": "2021-10-10T23:41:38Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "That's a good point, any thoughts @bbriscoe ?",
              "createdAt": "2021-10-10T23:41:38Z",
              "updatedAt": "2021-10-10T23:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uTRiE",
          "commit": {
            "abbreviatedOid": "f8aa220"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T01:15:44Z",
          "updatedAt": "2021-10-12T01:18:14Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I think this needs spelling out -- what about the acknowledging is different if the receiver treats this as ack-eliciting?",
              "createdAt": "2021-10-12T01:15:44Z",
              "updatedAt": "2021-10-12T01:18:14Z"
            },
            {
              "originalPosition": 15,
              "body": "Perhaps I'm missing something, but this is how I see it; please say more if I'm missing the point.\r\n\r\nAt a high level, the idea here is that the ECN machinery in general depends on the receiver of the CE signal relaying it back to the sender (as opposed to the congested switch/router directly sending a CE signal back to the sender, like ICMP Source-Quench). One could argue that the CE marking creates a need for signal delivery back to the sender, therefore making the CE-marked packets effectively ack-eliciting.\r\n\r\nThe value of receiving a CE mark early is so that the sender can take corresponding action in response to it. Receiving the mark sooner means the sender can reduce its sending rate sooner. ECN has a built in ~1RTT delay, so acking immediately is helpful to not increase that delay in the sender's response time.",
              "createdAt": "2021-10-12T01:16:48Z",
              "updatedAt": "2021-10-12T01:18:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uTqdJ",
          "commit": {
            "abbreviatedOid": "f8aa220"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T05:42:28Z",
          "updatedAt": "2021-10-12T05:42:29Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "@janaiyengar Let's say that there are two endpoints A and B, where A is sending data and B is acking them.\r\n\r\nThis paragraph is about ack-only packets sent by _B_ being CE-marked, and A sending ACK-of-ACKs at an earlier moment, with the goal being to somehow reduce the number of ack-only packets sent by B.\r\n\r\nWe can handle this type of congestion by possibly doing something like:\r\n* require A to reduce its send rate so that less ACKs would be generated by B, or\r\n* require A to send an ACK_FREQUENCY frame indicating B that ACKs should be sent less frequently, or\r\n* require B to send ACKs less frequently, in contrary to what has been requested by A though the ACK_FREQUENCY frame.\r\n\r\nHowever, we do not have any of these kind of mitigations being stated.\r\n\r\nA will continue sending at the same rate regardless of the proposed mechanism, because packets that were sent by A are not CE marked, and therefore B will continue acking them at the same rate.\r\n\r\nAs you can see, the added mechanism does not change the situation.",
              "createdAt": "2021-10-12T05:42:29Z",
              "updatedAt": "2021-10-12T05:42:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uWMGb",
          "commit": {
            "abbreviatedOid": "f8aa220"
          },
          "author": "mirjak",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T15:49:46Z",
          "updatedAt": "2021-10-12T15:49:47Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I agree with Jana: this change doesn't specify a reaction but the singling is needed to even be able to decide to implement any reaction in future. So I don't think we need to require a specific reaction here but of course we could add some text to give examples on how to react, in order to improve the understanding for the reader.",
              "createdAt": "2021-10-12T15:49:47Z",
              "updatedAt": "2021-10-12T15:49:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXMO1",
          "commit": {
            "abbreviatedOid": "f8aa220"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T20:27:49Z",
          "updatedAt": "2021-10-12T20:27:50Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Ah, good point, @kazuho. I'll think about this.",
              "createdAt": "2021-10-12T20:27:49Z",
              "updatedAt": "2021-10-12T20:27:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXOh7",
          "commit": {
            "abbreviatedOid": "f8aa220"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T20:35:34Z",
          "updatedAt": "2021-10-12T20:35:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nDoing this maintains the peer's response time to congestion events, while also\r\n```",
              "createdAt": "2021-10-12T20:35:34Z",
              "updatedAt": "2021-10-12T20:35:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXPNW",
          "commit": {
            "abbreviatedOid": "a8c4cc8"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T20:39:04Z",
          "updatedAt": "2021-10-12T20:39:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\ncongestion controllers that mark more frequently than classic ECN {{?RFC3168}}.\r\n```",
              "createdAt": "2021-10-12T20:39:04Z",
              "updatedAt": "2021-10-12T20:39:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXVO0",
          "commit": {
            "abbreviatedOid": "c0f542e"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T21:09:52Z",
          "updatedAt": "2021-10-12T21:09:53Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I know that this paragraph has already been dropped, but FWIW, I'm not sure if I agree that signalling is needed to resolve this problem.\r\n\r\nThe principle that we have in this draft is that senders control how frequently acks are sent. If we are to apply this principle to the problem (ACK-only packets being CE-marked), then the solution would be for the receiver of those packets (A) to send ACK_FREQUENCY packets so that fewer acks would be sent.",
              "createdAt": "2021-10-12T21:09:53Z",
              "updatedAt": "2021-10-12T21:09:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uX8CP",
          "commit": {
            "abbreviatedOid": "c0f542e"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T02:16:13Z",
          "updatedAt": "2021-10-13T02:16:13Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yes, I agree, we don't need to handle the case of ACK packets carrying CE marks. That is a more complicated case, and one that I am happy to leave out of this draft for now.",
              "createdAt": "2021-10-13T02:16:13Z",
              "updatedAt": "2021-10-13T02:16:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDODddxTs4rz1Xq",
      "title": "Use RFC9000 frame formats",
      "url": "https://github.com/quicwg/ack-frequency/pull/69",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fixes #66",
      "createdAt": "2021-09-16T00:17:58Z",
      "updatedAt": "2021-09-17T21:08:54Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "2653d744076e98d40bf0b6240d82af2e84f0a2c9",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-frame-formats",
      "headRefOid": "fd9135603d3f7b6cec1483a2a183b6c8b2d0b598",
      "closedAt": "2021-09-17T21:08:54Z",
      "mergedAt": "2021-09-17T21:08:54Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "7976fcdf42b6c9893e3862e7833a214f93b0cac1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4tC3df",
          "commit": {
            "abbreviatedOid": "ba93d90"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T00:22:02Z",
          "updatedAt": "2021-09-16T00:22:03Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Name typi",
              "createdAt": "2021-09-16T00:22:02Z",
              "updatedAt": "2021-09-16T00:22:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tEQ6i",
          "commit": {
            "abbreviatedOid": "ba93d90"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-16T09:50:01Z",
          "updatedAt": "2021-09-16T09:50:04Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nIMMEDIATE_ACK Frame {\r\n```",
              "createdAt": "2021-09-16T09:50:01Z",
              "updatedAt": "2021-09-16T09:50:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4tK-bR",
          "commit": {
            "abbreviatedOid": "fd91356"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-17T20:54:31Z",
          "updatedAt": "2021-09-17T20:54:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDODddxTs4r99Me",
      "title": "Update draft-ietf-quic-ack-frequency.md",
      "url": "https://github.com/quicwg/ack-frequency/pull/75",
      "state": "CLOSED",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "PR clarifying the consequencies and traedoffs in adjusting the ACK Policy.",
      "createdAt": "2021-09-20T14:58:34Z",
      "updatedAt": "2021-10-25T10:31:57Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "7976fcdf42b6c9893e3862e7833a214f93b0cac1",
      "headRepository": "gorryfair/ack-frequency",
      "headRefName": "patch-1",
      "headRefOid": "5099610ad89c558bc784c17e6ec693ff26010fe4",
      "closedAt": "2021-10-25T10:31:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@gorryfair -- I've carried over some of this and added some other things in #101, which replaces this PR -- please take a look.",
          "createdAt": "2021-10-24T12:59:09Z",
          "updatedAt": "2021-10-24T12:59:09Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "The changes requested here will not be executed in the way this PR envisaged. However, I'm expecting the new revision to take most of the ideas here in some form or other. So I suggest the best action is that I use this old PR as a checklist for review of the new revision and raise new issues if any are needed.",
          "createdAt": "2021-10-25T10:31:56Z",
          "updatedAt": "2021-10-25T10:31:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4tQkNH",
          "commit": {
            "abbreviatedOid": "714d91b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the PR!\r\n\r\nI left a few comments, but I'm a bit unclear as to what you're attempting to fix?",
          "createdAt": "2021-09-21T05:36:13Z",
          "updatedAt": "2021-10-10T12:39:46Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n## Congestion Response {#congestion-response}\r\n```",
              "createdAt": "2021-09-21T05:36:13Z",
              "updatedAt": "2021-10-10T00:15:40Z"
            },
            {
              "originalPosition": 15,
              "body": "This is not accurate, expiration of a timer does not cause packet loss in QUIC.",
              "createdAt": "2021-10-10T00:11:30Z",
              "updatedAt": "2021-10-10T00:15:40Z"
            },
            {
              "originalPosition": 64,
              "body": "This depends upon the pacing algorithm, and the recovery draft strongly suggests pacing.",
              "createdAt": "2021-10-10T00:14:54Z",
              "updatedAt": "2021-10-10T00:15:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uTQUB",
          "commit": {
            "abbreviatedOid": "714d91b"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@gorryfair -- as @ianswett responded, there are issues in the PR. However there are a couple of pieces that are useful ... I'll pull them out in a separate PR.",
          "createdAt": "2021-10-12T01:00:36Z",
          "updatedAt": "2021-10-12T01:03:11Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I think the spirit of this can be useful in the draft, but as a suggestion for a sender that does not pace.",
              "createdAt": "2021-10-12T01:00:37Z",
              "updatedAt": "2021-10-12T01:03:11Z"
            },
            {
              "originalPosition": 29,
              "body": "This is useful, but not in the right place.",
              "createdAt": "2021-10-12T01:02:00Z",
              "updatedAt": "2021-10-12T01:03:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uUtle",
          "commit": {
            "abbreviatedOid": "714d91b"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T10:33:57Z",
          "updatedAt": "2021-10-12T10:33:57Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This statement was meant to be a good thing to support reducing the ACK Frequency, so I don't understand - To me QUIC uses a method similar to RACK with a probe timeout (PTO),  Section 6.2 of RC9002?",
              "createdAt": "2021-10-12T10:33:57Z",
              "updatedAt": "2021-10-12T10:33:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uUu0g",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T10:38:15Z",
          "updatedAt": "2021-10-12T10:38:15Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think it is clear that RFC9002 encourages pacing (which is good). This sentence was intended to also encourage some form of pacing if you do have larger jumps in the number of acknowledged bytes. I think other words could say that too.",
              "createdAt": "2021-10-12T10:38:15Z",
              "updatedAt": "2021-10-12T10:38:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uUvsi",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T10:41:46Z",
          "updatedAt": "2021-10-12T10:41:46Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Interested in what you mean: I intended the text to recommend a method that either paces; or limit to IWs; (or both). ",
              "createdAt": "2021-10-12T10:41:46Z",
              "updatedAt": "2021-10-12T10:41:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXV8A",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T21:13:50Z",
          "updatedAt": "2021-10-12T21:13:51Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Basically, I don't think we should introduce any requirements at the receiver. This extension is designed to make the sender responsible for how frequently it wants to receive acks, and the sender should deal with consequences of making that choice. As such, we can perhaps say again that the sender needs to handle this via pacing or other means.",
              "createdAt": "2021-10-12T21:13:50Z",
              "updatedAt": "2021-10-12T21:13:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXWJ2",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T21:15:04Z",
          "updatedAt": "2021-10-12T21:15:05Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "The PTO triggers a new packet, but does not cause loss detection. QUIC loss detection happens only on receiving an ACK. Doing so allows a QUIC sender to detect unnecessary retransmissions, since the rtxs all have new packet numbers.",
              "createdAt": "2021-10-12T21:15:05Z",
              "updatedAt": "2021-10-12T21:15:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXWvR",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T21:18:23Z",
          "updatedAt": "2021-10-12T21:18:24Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "The point below is not quite accurate. Reducing periodicity of RTT measurements is not necessarily going to postpone any retransmission, since that depends on the network itself and how stationary the RTT distribution is. I understand that there is an interaction between fewer acks being received and loss detection, and that might be worth noting.",
              "createdAt": "2021-10-12T21:18:24Z",
              "updatedAt": "2021-10-12T21:18:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uZV6u",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T10:39:35Z",
          "updatedAt": "2021-10-13T10:39:35Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Then, I think we do not agree. I see this as about how the receiver is required to function (even if the server takes control) - My position is that it does not matter whether this function is controlled by the sender or a part of the receiver spec. \"Pacing\" is likely a good recommendation (sigh... if only it was posisble to make more actionable details of how to pace). Since this can have significant impact on the traffic patterns, we need to say specify something, and I think it is wrong to just say \"or other means\". ",
              "createdAt": "2021-10-13T10:39:35Z",
              "updatedAt": "2021-10-13T10:39:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uZX7n",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T10:48:26Z",
          "updatedAt": "2021-10-13T10:48:27Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think we might be converging: Of course we agree that if the RTT doesn't change, then the RTT frequency doesn't impact retransmission.  OK.  So I see it's valid to say QUIC PTO isn't loss detection - but the reason the timer fires is because the sender expected a response. This sounds like wordsmithing which is worthwhile.\r\nAs a specification for the Internet, we should be assuming that a design needs to be robust to changeable paths - framing it that way would be OK for me.",
              "createdAt": "2021-10-13T10:48:26Z",
              "updatedAt": "2021-10-13T10:48:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8B_h",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T09:23:23Z",
          "updatedAt": "2021-10-24T09:23:23Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "We're disagreeing about different things :-) My point is about not requiring things at the _receiver_. This choice of ack frequency is entirely a sender decision, and while we can require the sender to do things sensibly, I don't think we want to add requirements at the receiver to second-guess the sender. Especially, since the receiver does not know the sender's congestion window or controller.",
              "createdAt": "2021-10-24T09:23:23Z",
              "updatedAt": "2021-10-24T09:23:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u9u91",
          "commit": {
            "abbreviatedOid": "5099610"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T10:28:05Z",
          "updatedAt": "2021-10-25T10:28:05Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "So, I do think we are indeed disagreeing about different things :-). While I talked in terms of what the receiver ought to do, I'd agree that ANY additional requirements or advice on the ACK policy would be requirements or advice for how a SENDER asks the RECEIVER to behave. ",
              "createdAt": "2021-10-25T10:28:05Z",
              "updatedAt": "2021-10-25T10:28:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 77,
      "id": "PR_kwDODddxTs4sk8YG",
      "title": "Clarify an endpoint can send less ACKs when processing packets in a batch.",
      "url": "https://github.com/quicwg/ack-frequency/pull/77",
      "state": "CLOSED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes issue #30.",
      "createdAt": "2021-10-01T19:18:25Z",
      "updatedAt": "2021-10-01T20:36:34Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "7976fcdf42b6c9893e3862e7833a214f93b0cac1",
      "headRepository": "rpaulo/ack-frequency",
      "headRefName": "less-acks-batch",
      "headRefOid": "c47a7a74816a4dacf579ef670e0ff592257326e6",
      "closedAt": "2021-10-01T20:36:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Where does RFC 9000 specifically talk about batching?",
          "createdAt": "2021-10-01T20:27:11Z",
          "updatedAt": "2021-10-01T20:27:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "\"A receiver MAY process multiple available packets before determining\r\n whether to send an ACK frame in response.\" from Section 13.2.2: https://datatracker.ietf.org/doc/html/rfc9000#section-13.2.2",
          "createdAt": "2021-10-01T20:29:51Z",
          "updatedAt": "2021-10-01T20:29:51Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You added that section in f8fc854dc back in 2019 but I don't think it was clear enough.  @janaiyengar cleared up that section in May (or so) 2020 which was after I wrote issue #30.  I'll close.",
          "createdAt": "2021-10-01T20:36:34Z",
          "updatedAt": "2021-10-01T20:36:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4t2sq2",
          "commit": {
            "abbreviatedOid": "1913ac2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T19:31:31Z",
          "updatedAt": "2021-10-01T19:31:32Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nwait to process all available packets in a batch before sending an\r\nacknowledgement.\r\n```",
              "createdAt": "2021-10-01T19:31:31Z",
              "updatedAt": "2021-10-01T19:31:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4t21fE",
          "commit": {
            "abbreviatedOid": "c47a7a7"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "One question on this PR.  It seems somewhat duplicative of what's in RFC9000.  Can you clarify what's new?",
          "createdAt": "2021-10-01T20:23:55Z",
          "updatedAt": "2021-10-01T20:23:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDODddxTs4slFMO",
      "title": "Improve Ignore Order explanation.",
      "url": "https://github.com/quicwg/ack-frequency/pull/78",
      "state": "MERGED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes issue #76.",
      "createdAt": "2021-10-01T20:20:54Z",
      "updatedAt": "2021-10-09T22:52:55Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "7976fcdf42b6c9893e3862e7833a214f93b0cac1",
      "headRepository": "rpaulo/ack-frequency",
      "headRefName": "ignore-reorder-wording",
      "headRefOid": "6aaeda11f68f91a3d840bd6512718c859a55e048",
      "closedAt": "2021-10-09T22:52:55Z",
      "mergedAt": "2021-10-09T22:52:55Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "2172c24df098c408456f2f30bba56ba3bf27e2b1"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the PR!",
          "createdAt": "2021-10-09T22:52:04Z",
          "updatedAt": "2021-10-09T22:52:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4t21Ri",
          "commit": {
            "abbreviatedOid": "956f88f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T20:22:50Z",
          "updatedAt": "2021-10-01T20:22:50Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n: An 8-bit field representing a boolean truth value. This field is\r\n```",
              "createdAt": "2021-10-01T20:22:50Z",
              "updatedAt": "2021-10-01T20:22:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uOuwt",
          "commit": {
            "abbreviatedOid": "6aaeda1"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-09T22:51:41Z",
          "updatedAt": "2021-10-09T22:51:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDODddxTs4srXEA",
      "title": "Note update",
      "url": "https://github.com/quicwg/ack-frequency/pull/81",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "You aren't using .note.xml, so remove it.\r\n\r\nI updated the links so that the text rendering doesn't include them twice.\r\n\r\n~~Plus a free closed brace.~~",
      "createdAt": "2021-10-05T06:53:14Z",
      "updatedAt": "2021-10-05T14:55:11Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "7976fcdf42b6c9893e3862e7833a214f93b0cac1",
      "headRepository": "martinthomson/ack-frequency",
      "headRefName": "note-update",
      "headRefOid": "01d178702081619f6937fac25bcef5c08d1622f8",
      "closedAt": "2021-10-05T14:55:11Z",
      "mergedAt": "2021-10-05T14:55:11Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "b2878163d3fad6b5b217f953f542582b0368ffc8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4t_STw",
          "commit": {
            "abbreviatedOid": "01d1787"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T14:55:06Z",
          "updatedAt": "2021-10-05T14:55:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDODddxTs4srXdk",
      "title": "Section references",
      "url": "https://github.com/quicwg/ack-frequency/pull/82",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Better section references.",
      "createdAt": "2021-10-05T06:56:11Z",
      "updatedAt": "2021-10-05T14:57:48Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "7976fcdf42b6c9893e3862e7833a214f93b0cac1",
      "headRepository": "martinthomson/ack-frequency",
      "headRefName": "section-ref",
      "headRefOid": "93a67267f73667f73e72adb5ce6cb77669b162ac",
      "closedAt": "2021-10-05T14:57:48Z",
      "mergedAt": "2021-10-05T14:57:48Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5cfcf482a9c0189d0067621b0ae7921714aa3df1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4t_TIu",
          "commit": {
            "abbreviatedOid": "93a6726"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T14:57:36Z",
          "updatedAt": "2021-10-05T14:57:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDODddxTs4srXoS",
      "title": "Remove travis config",
      "url": "https://github.com/quicwg/ack-frequency/pull/83",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-05T06:57:25Z",
      "updatedAt": "2021-10-05T14:56:40Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "7976fcdf42b6c9893e3862e7833a214f93b0cac1",
      "headRepository": "martinthomson/ack-frequency",
      "headRefName": "travis",
      "headRefOid": "2f762a4112fd2fe301e4f289a4717295f020bd0d",
      "closedAt": "2021-10-05T14:56:40Z",
      "mergedAt": "2021-10-05T14:56:40Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "3042b2b6475940a4ccbb4c0742ddaf872a6ee987"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4t_StH",
          "commit": {
            "abbreviatedOid": "2f762a4"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T14:56:17Z",
          "updatedAt": "2021-10-05T14:56:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDODddxTs4s-_uO",
      "title": "Clarify Ack-Eliciting threshold",
      "url": "https://github.com/quicwg/ack-frequency/pull/86",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fixes #85",
      "createdAt": "2021-10-10T14:04:47Z",
      "updatedAt": "2021-10-12T10:57:34Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "2172c24df098c408456f2f30bba56ba3bf27e2b1",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-clarify-threshold",
      "headRefOid": "91fb6f0e2579cc85d3493fb029bb5c9d31ea9b67",
      "closedAt": "2021-10-12T10:57:34Z",
      "mergedAt": "2021-10-12T10:57:34Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "3a5e0b41df7515b4984730189f2d648b5443725c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4uPL2e",
          "commit": {
            "abbreviatedOid": "ce4656a"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "A good change, not sure about the other part.",
          "createdAt": "2021-10-11T00:28:09Z",
          "updatedAt": "2021-10-11T00:28:22Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This change is otherwise good, but I wonder if this requirement isn't nonsensical.  It's a 62-bit value that we know can be used by endpoints.  The challenge is that values beyond a certain point are certain to produce bad outcomes; you don't want that, but it seems like you don't want to commit to a specific limit.  I'll open an issue.",
              "createdAt": "2021-10-11T00:28:09Z",
              "updatedAt": "2021-10-11T00:28:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uQvKT",
          "commit": {
            "abbreviatedOid": "ce4656a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T11:51:35Z",
          "updatedAt": "2021-10-11T11:51:36Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This sentence didn't change(ok, I capitalized the E and T of ACK-Eliciting Threshold) FYI",
              "createdAt": "2021-10-11T11:51:35Z",
              "updatedAt": "2021-10-11T11:51:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uTOuQ",
          "commit": {
            "abbreviatedOid": "ce4656a"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-12T00:40:53Z",
          "updatedAt": "2021-10-12T00:42:11Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n  Threshold value that is larger than the maximum value the endpoint can represent, the\r\n```",
              "createdAt": "2021-10-12T00:40:53Z",
              "updatedAt": "2021-10-12T00:42:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDODddxTs4s_CNd",
      "title": "Add an Ignore ECN bool similar to Ignore Order",
      "url": "https://github.com/quicwg/ack-frequency/pull/88",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #87",
      "createdAt": "2021-10-10T15:01:39Z",
      "updatedAt": "2021-10-21T13:20:55Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "02ca7c4b6eb6ca28b356bd72ac347d4020a3f68e",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-ignore-ecn",
      "headRefOid": "bbb0840cfbc01acd0b29bd99403d3a0c84228abf",
      "closedAt": "2021-10-21T13:20:55Z",
      "mergedAt": "2021-10-21T13:20:55Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "08774467b07c40690921bcbef1b00715b8247383"
      },
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "I think we shouldn't make this change until we understand the use case for this field. IMO, it is harmful to the networks.\r\n\r\nHappy to discuss this over slack or at #87 ",
          "createdAt": "2021-10-15T08:25:21Z",
          "updatedAt": "2021-10-15T08:25:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4uWRdG",
          "commit": {
            "abbreviatedOid": "3cdd3d9"
          },
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T16:08:29Z",
          "updatedAt": "2021-10-12T16:08:29Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Similarly all other values are `FRAME_ENCODING_ERROR`.",
              "createdAt": "2021-10-12T16:08:29Z",
              "updatedAt": "2021-10-12T16:08:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXTxP",
          "commit": {
            "abbreviatedOid": "3cdd3d9"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T21:02:22Z",
          "updatedAt": "2021-10-12T21:02:23Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "It's only a single bit now, so there's no ability to incorrectly encode it.",
              "createdAt": "2021-10-12T21:02:22Z",
              "updatedAt": "2021-10-12T21:02:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXTC-",
          "commit": {
            "abbreviatedOid": "3cdd3d9"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is forward-looking a bit, but I think this is reasonable.",
          "createdAt": "2021-10-12T20:58:47Z",
          "updatedAt": "2021-10-12T21:02:40Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Add a \"Reserved\" 6-bit field, so that this frame ends on a byte boundary.",
              "createdAt": "2021-10-12T20:58:47Z",
              "updatedAt": "2021-10-12T21:02:40Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n  0 represents 'false' and 1 represents 'true'.\r\n```",
              "createdAt": "2021-10-12T21:01:17Z",
              "updatedAt": "2021-10-12T21:02:40Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n: A single bit field representing a boolean truth value. This field is\r\n```",
              "createdAt": "2021-10-12T21:01:35Z",
              "updatedAt": "2021-10-12T21:02:40Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n: A single bit field representing a boolean truth value. This field is\r\n```",
              "createdAt": "2021-10-12T21:01:43Z",
              "updatedAt": "2021-10-12T21:02:40Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n  acknowledgement when the peer receives CE-marked packets ({{reordering}}).\r\n```",
              "createdAt": "2021-10-12T21:02:02Z",
              "updatedAt": "2021-10-12T21:02:40Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nIgnore CE:\r\n```",
              "createdAt": "2021-10-12T21:02:32Z",
              "updatedAt": "2021-10-12T21:02:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXixO",
          "commit": {
            "abbreviatedOid": "3cdd3d9"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T22:26:02Z",
          "updatedAt": "2021-10-12T22:26:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "You might want to put that reserved field ahead of these two bits so that these take 0x01 and 0x02 rather than 0x80 and 0x40.",
              "createdAt": "2021-10-12T22:26:02Z",
              "updatedAt": "2021-10-12T22:26:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uXnct",
          "commit": {
            "abbreviatedOid": "3cdd3d9"
          },
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T23:02:38Z",
          "updatedAt": "2021-10-12T23:02:38Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Sigh. I assumed it was just like the other value. ",
              "createdAt": "2021-10-12T23:02:38Z",
              "updatedAt": "2021-10-12T23:02:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4ugHh1",
          "commit": {
            "abbreviatedOid": "bfdcbe5"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T19:35:00Z",
          "updatedAt": "2021-10-14T19:35:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks, done!",
              "createdAt": "2021-10-14T19:35:00Z",
              "updatedAt": "2021-10-14T19:35:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4ugcye",
          "commit": {
            "abbreviatedOid": "bfdcbe5"
          },
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T21:14:56Z",
          "updatedAt": "2021-10-14T21:16:02Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\n  0 represents 'false' and 1 represents 'true'.\n```\n",
              "createdAt": "2021-10-14T21:14:56Z",
              "updatedAt": "2021-10-14T21:16:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u1HHB",
          "commit": {
            "abbreviatedOid": "1f33477"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T13:12:07Z",
          "updatedAt": "2021-10-21T13:13:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n  Ignore CE (1),\r\n```",
              "createdAt": "2021-10-21T13:12:07Z",
              "updatedAt": "2021-10-21T13:13:01Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n: A 1-bit field representing a boolean truth value. This field is\r\n```",
              "createdAt": "2021-10-21T13:12:23Z",
              "updatedAt": "2021-10-21T13:13:01Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n: A 1-bit field representing a boolean truth value. This field is\r\n```",
              "createdAt": "2021-10-21T13:12:38Z",
              "updatedAt": "2021-10-21T13:13:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u1J4x",
          "commit": {
            "abbreviatedOid": "bbb0840"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-21T13:20:48Z",
          "updatedAt": "2021-10-21T13:20:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDODddxTs4tDEg7",
      "title": "Apply 1/2 of  a change that was lost",
      "url": "https://github.com/quicwg/ack-frequency/pull/91",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "@rpaulo posted that this change was missed.  This pulls in the first part, and I think the second part has been superceded.\r\n\r\nhttps://github.com/quicwg/ack-frequency/commit/8a87dbd3d38c40507a2ca346f242fbdee3866ec3\r\n\r\nFixes #90 ",
      "createdAt": "2021-10-12T03:18:44Z",
      "updatedAt": "2021-10-12T15:22:29Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "2172c24df098c408456f2f30bba56ba3bf27e2b1",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-old-pr",
      "headRefOid": "3814465df669fc1f5f045f78bb4fe2fd7dd7b7fe",
      "closedAt": "2021-10-12T09:57:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should be PROTOCOL_VIOLATION since it\u2019s not a TP anymore?",
          "createdAt": "2021-10-12T06:24:35Z",
          "updatedAt": "2021-10-12T06:24:35Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I realize this wasn't lost, this was superseded by the following paragraph, which says that it can't be larger than the max_ack_delay.\r\n\r\nAs a result, I think I should close this PR and the issue?",
          "createdAt": "2021-10-12T09:51:23Z",
          "updatedAt": "2021-10-12T09:51:23Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That doesn\u2019t make sense to me. How come Requested Max Ack Delay can\u2019t be larger than the original Max Ack Delay?",
          "createdAt": "2021-10-12T14:20:46Z",
          "updatedAt": "2021-10-12T14:20:46Z"
        },
        {
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "body": " Ok I understand now that you only changed min ack delay. However, Why do you think the second part has been superseded?\r\nI was referring to the fact that the text about the request max ack delay in the ack frequency frame doesn\u2019t call out the 2^14 limit. ",
          "createdAt": "2021-10-12T15:22:28Z",
          "updatedAt": "2021-10-12T15:22:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 92,
      "id": "PR_kwDODddxTs4tD-iN",
      "title": "Change 'are' to 'can be' undesirable consequences",
      "url": "https://github.com/quicwg/ack-frequency/pull/92",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #71",
      "createdAt": "2021-10-12T09:59:02Z",
      "updatedAt": "2021-10-12T18:59:04Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "2172c24df098c408456f2f30bba56ba3bf27e2b1",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-can-be",
      "headRefOid": "3764886e6b8ce855a3ba952c6eab1f1c0c2f2f71",
      "closedAt": "2021-10-12T18:59:04Z",
      "mergedAt": "2021-10-12T18:59:04Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "4d25d133baebad4173f717177e62dfe93304a1c8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4uUsQl",
          "commit": {
            "abbreviatedOid": "3764886"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "This seems an improvement, thanks.",
          "createdAt": "2021-10-12T10:28:14Z",
          "updatedAt": "2021-10-12T10:28:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDODddxTs4tLHiL",
      "title": "Fix whitespace problems from 956f88fd.",
      "url": "https://github.com/quicwg/ack-frequency/pull/94",
      "state": "MERGED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\n227:  The value of this field MUST be 0x00 (representing `false`) or 0x01 \r\ndraft-ietf-quic-ack-frequency.md contains trailing whitespace\r\n```",
      "createdAt": "2021-10-14T01:29:14Z",
      "updatedAt": "2021-10-14T08:21:04Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "1fcf6a17e8f9bbfb3a51e9d6f02046bb3401ef5b",
      "headRepository": "rpaulo/ack-frequency",
      "headRefName": "fix-whitespace",
      "headRefOid": "b514c43c2ad5875cece8b8720feec96a74ca3847",
      "closedAt": "2021-10-14T08:21:04Z",
      "mergedAt": "2021-10-14T08:21:04Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "e8a3bc0569dcaec912ab7aaa97b148a9d8ed53dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4udYCt",
          "commit": {
            "abbreviatedOid": "b514c43"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-14T08:20:36Z",
          "updatedAt": "2021-10-14T08:20:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDODddxTs4tLKj6",
      "title": "Implementation considerations for migration and PMTUD",
      "url": "https://github.com/quicwg/ack-frequency/pull/95",
      "state": "MERGED",
      "author": "rpaulo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #79.",
      "createdAt": "2021-10-14T01:55:15Z",
      "updatedAt": "2021-10-21T13:11:05Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "1fcf6a17e8f9bbfb3a51e9d6f02046bb3401ef5b",
      "headRepository": "rpaulo/ack-frequency",
      "headRefName": "migration-and-pmtud",
      "headRefOid": "0c868007cf9d5305882db0a531c841a2b4ef94e6",
      "closedAt": "2021-10-21T13:11:05Z",
      "mergedAt": "2021-10-21T13:11:05Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "02ca7c4b6eb6ca28b356bd72ac347d4020a3f68e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4udZ0m",
          "commit": {
            "abbreviatedOid": "ce24e45"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some small suggestions, but looking good.\r\n\r\nThanks for writing this up, it's very helpful!",
          "createdAt": "2021-10-14T08:27:26Z",
          "updatedAt": "2021-10-14T08:28:45Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is a MUST in RFC9000, so I made a suggestion.\r\nhttps://datatracker.ietf.org/doc/html/rfc9000#section-9.4\r\n\r\n```suggestion\r\nafter migration.  The congestion controller and rtt estimator are reset upon migration ({{Section 9.4 of QUIC-TRANSPORT}}), which may lead to\r\n```",
              "createdAt": "2021-10-14T08:27:26Z",
              "updatedAt": "2021-10-14T08:28:27Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nundesirable performance if the acknowledgement behavior isn't updated\r\n```",
              "createdAt": "2021-10-14T08:27:47Z",
              "updatedAt": "2021-10-14T08:28:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4ugJtD",
          "commit": {
            "abbreviatedOid": "53f95ed"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T19:45:36Z",
          "updatedAt": "2021-10-14T19:45:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nafter migration.  Once the congestion controller and rtt estimator are reset upon migration ({{Section 9.4 of QUIC-TRANSPORT}}), an updated ACK_FREQUENCY frame SHOULD be sent to reflect the new rtt and congestion control parameters.\r\n```",
              "createdAt": "2021-10-14T19:45:36Z",
              "updatedAt": "2021-10-14T19:45:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4ugGlj",
          "commit": {
            "abbreviatedOid": "ce24e45"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @rpaulo -- a few suggestions, but thanks for the PR!",
          "createdAt": "2021-10-14T19:30:23Z",
          "updatedAt": "2021-10-14T20:05:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nTo avoid additional delays to connection migration confirmation when using this extension,\r\n```",
              "createdAt": "2021-10-14T19:30:24Z",
              "updatedAt": "2021-10-14T20:05:26Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nframe ({{Section 9.2 of QUIC-TRANSPORT}}) it sends or it can\r\n```",
              "createdAt": "2021-10-14T19:33:24Z",
              "updatedAt": "2021-10-14T20:05:26Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nAn endpoint's congestion controller and RTT estimator are reset upon\r\nconfirmation of migration ({{Section 9.4 of QUIC-TRANSPORT}}), which can have\r\nadverse impact on the number of acknowledgements received after migration. An\r\nendpoint that has sent an ACK_FREQUENCY frame earlier in the connection SHOULD\r\nupdate and send a new ACK_FREQUENCY frame immediately upon confirmation of\r\nconnection migration.\r\n```",
              "createdAt": "2021-10-14T19:57:57Z",
              "updatedAt": "2021-10-14T20:05:26Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nA sender might use timers to detect loss of PMTUD probe packets. A sender\r\nSHOULD bundle an IMMEDIATE_ACK frame with any PTMUD probes to avoid triggering\r\nsuch timers.\r\n```",
              "createdAt": "2021-10-14T20:04:25Z",
              "updatedAt": "2021-10-14T20:05:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4ugXod",
          "commit": {
            "abbreviatedOid": "4425bdd"
          },
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T20:52:16Z",
          "updatedAt": "2021-10-14T20:52:16Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "\"clients .... they send or they\"\r\n\"a client ... it sends or it can\"\r\n\r\nPick one ;-) ",
              "createdAt": "2021-10-14T20:52:16Z",
              "updatedAt": "2021-10-14T20:52:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4ugX0A",
          "commit": {
            "abbreviatedOid": "4425bdd"
          },
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T20:53:10Z",
          "updatedAt": "2021-10-14T20:53:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This looks good to me.  Since this changes text that @ianswett wrote, I'll let him commit the suggestion.",
              "createdAt": "2021-10-14T20:53:10Z",
              "updatedAt": "2021-10-14T20:53:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4ugYLZ",
          "commit": {
            "abbreviatedOid": "4425bdd"
          },
          "author": "rpaulo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T20:54:56Z",
          "updatedAt": "2021-10-14T20:54:56Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "What I wanted to say is that it's not impossible to come up with an implementation for PMTUD that takes into account the last acknowledged ACK_FREQUENCY and still works correctly, but implementers must tread carefully.  I agree that we should change the latest sentence to a SHOULD.",
              "createdAt": "2021-10-14T20:54:56Z",
              "updatedAt": "2021-10-14T20:54:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4uiAyR",
          "commit": {
            "abbreviatedOid": "318fa35"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-15T09:57:11Z",
          "updatedAt": "2021-10-15T09:57:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4ulEkM",
          "commit": {
            "abbreviatedOid": "d9223ac"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "These changes both look good to me.",
          "createdAt": "2021-10-17T16:51:01Z",
          "updatedAt": "2021-10-17T16:51:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u1GXF",
          "commit": {
            "abbreviatedOid": "d9223ac"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-21T13:09:41Z",
          "updatedAt": "2021-10-21T13:10:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nextension, a client can bundle an IMMEDIATE_ACK frame with the first non-probing\r\n```",
              "createdAt": "2021-10-21T13:09:41Z",
              "updatedAt": "2021-10-21T13:10:39Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nconfirmation of migration ({{Section 9.4 of QUIC-TRANSPORT}}), which can\r\nimpact the number of acknowledgements received after migration. An\r\n```",
              "createdAt": "2021-10-21T13:10:13Z",
              "updatedAt": "2021-10-21T13:10:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDODddxTs4tfxzI",
      "title": "Clarify the purpose of min_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/97",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fixes #80",
      "createdAt": "2021-10-21T13:55:07Z",
      "updatedAt": "2021-10-21T14:01:24Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "08774467b07c40690921bcbef1b00715b8247383",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-min-ack-delay",
      "headRefOid": "c13100f17f64cf27d53e48ccef19769e02e74c91",
      "closedAt": "2021-10-21T14:01:23Z",
      "mergedAt": "2021-10-21T14:01:23Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "3890d4416135c21d1ec46b1fca2b91078b5bbc46"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDODddxTs4tfyGo",
      "title": "Remove MUST for non-conforming implementations",
      "url": "https://github.com/quicwg/ack-frequency/pull/98",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Closes #89.",
      "createdAt": "2021-10-21T13:56:21Z",
      "updatedAt": "2021-10-25T11:12:49Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "3c31c3043afc5172bc0bd39e89e2d7c2c6017af0",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/lt64",
      "headRefOid": "9f536ae149c43062094765b943e8225070fee661",
      "closedAt": "2021-10-25T11:12:49Z",
      "mergedAt": "2021-10-25T11:12:49Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "0df1498cec0db49858234603792b3635268e44b8"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@nibanks -- thoughts?",
          "createdAt": "2021-10-24T09:17:14Z",
          "updatedAt": "2021-10-24T09:17:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4u1cRb",
          "commit": {
            "abbreviatedOid": "0808949"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-21T14:13:44Z",
          "updatedAt": "2021-10-21T14:13:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u14D7",
          "commit": {
            "abbreviatedOid": "0808949"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Silence is golden.",
          "createdAt": "2021-10-21T15:37:28Z",
          "updatedAt": "2021-10-21T15:37:47Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n  an immediate acknowledgement.\r\n```",
              "createdAt": "2021-10-21T15:37:29Z",
              "updatedAt": "2021-10-21T15:37:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u2Fsu",
          "commit": {
            "abbreviatedOid": "0808949"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T16:24:18Z",
          "updatedAt": "2021-10-21T16:24:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@martinthomson -- there's at least one implementation that is doing this, and having a recommendation here seems reasonable.",
              "createdAt": "2021-10-21T16:24:18Z",
              "updatedAt": "2021-10-21T16:24:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u3iC0",
          "commit": {
            "abbreviatedOid": "0808949"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T00:32:04Z",
          "updatedAt": "2021-10-22T00:32:04Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I don't agree.  This is a pointless optimization (7 bytes at best, and possibly less in practice).  It might be safe to do this, it might even be a good idea, but unless you have a better reason, I would prefer not to formally condone this.",
              "createdAt": "2021-10-22T00:32:04Z",
              "updatedAt": "2021-10-22T00:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u3n29",
          "commit": {
            "abbreviatedOid": "0808949"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T01:15:23Z",
          "updatedAt": "2021-10-22T01:15:24Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yeah I think what we might want to say is that receivers MAY send acks more frequently than what is indicated by the sender, rather than stating one way of _how_ that can happen.",
              "createdAt": "2021-10-22T01:15:23Z",
              "updatedAt": "2021-10-22T01:15:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8GLI",
          "commit": {
            "abbreviatedOid": "0808949"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T12:22:02Z",
          "updatedAt": "2021-10-24T12:22:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'm fine with phrasing this that peers might acknowledge earlier.",
              "createdAt": "2021-10-24T12:22:02Z",
              "updatedAt": "2021-10-24T12:22:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8MWW",
          "commit": {
            "abbreviatedOid": "2ec13f0"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Ok, I've reworded to simply say that a receiver can ack earlier. PTAL @martinthomson @nibanks @kazuho @ianswett ",
          "createdAt": "2021-10-24T16:34:07Z",
          "updatedAt": "2021-10-24T16:34:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u8MYf",
          "commit": {
            "abbreviatedOid": "2ec13f0"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Good direction, but some small suggestions.",
          "createdAt": "2021-10-24T16:35:51Z",
          "updatedAt": "2021-10-24T16:36:37Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Q: Why did you change this sentence?  I actually preferred the old text \"An immediate acknowledgement ...\"",
              "createdAt": "2021-10-24T16:35:51Z",
              "updatedAt": "2021-10-24T16:36:37Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n  a receiver immediately acknowledging every ack-eliciting packet.\r\n```",
              "createdAt": "2021-10-24T16:36:24Z",
              "updatedAt": "2021-10-24T16:36:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8NCZ",
          "commit": {
            "abbreviatedOid": "100dc87"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T17:08:28Z",
          "updatedAt": "2021-10-24T17:09:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I've changed two things:\r\n- the first part of the original sentence applies broadly, not just the case of 0, and it is a restating of the first sentence in this para, and I've made that explicit,\r\n- when an endpoint sends an ack, it sends an ack, not an \"immediate ack\". In this context, \"immediate\" is not required, since we are talking about the endpoint doing something (sending an ack) on an event (threshold is exceeded).",
              "createdAt": "2021-10-24T17:08:28Z",
              "updatedAt": "2021-10-24T17:09:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8QAz",
          "commit": {
            "abbreviatedOid": "9f536ae"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T19:37:25Z",
          "updatedAt": "2021-10-24T19:37:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u8RL6",
          "commit": {
            "abbreviatedOid": "9f536ae"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T20:39:38Z",
          "updatedAt": "2021-10-24T20:39:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u8TJ0",
          "commit": {
            "abbreviatedOid": "9f536ae"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "WFM",
          "createdAt": "2021-10-24T22:17:33Z",
          "updatedAt": "2021-10-24T22:17:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u8VVw",
          "commit": {
            "abbreviatedOid": "9f536ae"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T23:42:21Z",
          "updatedAt": "2021-10-24T23:42:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDODddxTs4tin4D",
      "title": "Replace reordering with out of order",
      "url": "https://github.com/quicwg/ack-frequency/pull/99",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fixes #62\r\n\r\n@gloinul tell me if this is sufficient, or if you wanted more references to RFC9000.",
      "createdAt": "2021-10-22T10:07:36Z",
      "updatedAt": "2021-10-24T09:17:33Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "3890d4416135c21d1ec46b1fca2b91078b5bbc46",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-out-of-order",
      "headRefOid": "4ce6425837758632fadd46d852adb3cc8c575732",
      "closedAt": "2021-10-24T09:17:33Z",
      "mergedAt": "2021-10-24T09:17:32Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "3c31c3043afc5172bc0bd39e89e2d7c2c6017af0"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I'm open to other suggestions if you have them, but nothing else stuck out at me.  I'm reluctant to repeat the full definition of out of order in this document, given it's well defined in RFC9000.",
          "createdAt": "2021-10-22T13:01:33Z",
          "updatedAt": "2021-10-22T13:01:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4u5csL",
          "commit": {
            "abbreviatedOid": "2165224"
          },
          "author": "gloinul",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Ok, I think this is truly the bare minimal to resolve my issue. There exist a clearer chain back towards Section 13.2.1 in RFC9000 and I guess that is sufficient. ",
          "createdAt": "2021-10-22T12:56:26Z",
          "updatedAt": "2021-10-22T12:56:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u8Bow",
          "commit": {
            "abbreviatedOid": "2165224"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "A couple of minor edits, but lgtm",
          "createdAt": "2021-10-24T09:06:47Z",
          "updatedAt": "2021-10-24T09:14:58Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\npacket, and for every packet that is received out of order (Section\r\n13.2.1 of {{QUIC-TRANSPORT}}). This\r\n```",
              "createdAt": "2021-10-24T09:06:48Z",
              "updatedAt": "2021-10-24T09:14:58Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n  acknowledgement when the peer receives a packet out of order\r\n```",
              "createdAt": "2021-10-24T09:07:03Z",
              "updatedAt": "2021-10-24T09:14:58Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n## Response to Out-of-Order Packets {#out-of-order}\r\n```",
              "createdAt": "2021-10-24T09:07:28Z",
              "updatedAt": "2021-10-24T09:14:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDODddxTs4tislH",
      "title": "Change 'Ignore Order' to 'Reordering Threshold'",
      "url": "https://github.com/quicwg/ack-frequency/pull/100",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #96 ",
      "createdAt": "2021-10-22T10:32:49Z",
      "updatedAt": "2021-10-24T23:44:22Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "3c31c3043afc5172bc0bd39e89e2d7c2c6017af0",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-reordering-threshold",
      "headRefOid": "4fe56e9ded587f1836dc97f3c55e04ef83d237ca",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have a strong opinion on a varint vs 7 bits.  I suspect 7 bits is more than enough, but I could go either way.",
          "createdAt": "2021-10-24T19:40:58Z",
          "updatedAt": "2021-10-24T19:40:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4u7w_H",
          "commit": {
            "abbreviatedOid": "15c74bd"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thank you for working on this. Looks good.\r\n\r\n* I was a bit surprised to see Reordering Threshold being represented as a 7-bit value. I was expecting an ordinary \"(i)\" value. Though that's a matter of taste. I agree that having 7 bits would be more than enough.\r\n* There's one more mention of \"Ignore Order\" left at the end of the \"Computation of Probe Timeout Period\" section.",
          "createdAt": "2021-10-23T19:36:40Z",
          "updatedAt": "2021-10-23T19:43:59Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Maybe revert this change? This sentence is talking about Ignore CE.\r\n\r\nI think you might have edited the wrong place and forgot to revert.",
              "createdAt": "2021-10-23T19:36:40Z",
              "updatedAt": "2021-10-23T19:43:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8QEF",
          "commit": {
            "abbreviatedOid": "96738d2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T19:40:27Z",
          "updatedAt": "2021-10-24T19:40:28Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Good catch, reverted.",
              "createdAt": "2021-10-24T19:40:27Z",
              "updatedAt": "2021-10-24T19:40:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8RKT",
          "commit": {
            "abbreviatedOid": "4fe56e9"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T20:37:53Z",
          "updatedAt": "2021-10-24T20:37:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u8VZB",
          "commit": {
            "abbreviatedOid": "4fe56e9"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T23:44:22Z",
          "updatedAt": "2021-10-24T23:44:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "PR_kwDODddxTs4tlvgY",
      "title": "Consolidate congestion and timer requirements of ack frequency",
      "url": "https://github.com/quicwg/ack-frequency/pull/101",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #72.\r\nCloses #73.\r\nCloses #74.\r\nCloses #75.\r\nCloses #93.",
      "createdAt": "2021-10-24T12:57:55Z",
      "updatedAt": "2021-10-25T17:40:56Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "6117149d0d40634b1207a02afb8992d1e2b3ef0f",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/recommend",
      "headRefOid": "871fe58bfe86926f7d6121b0b28509b803594cbf",
      "closedAt": "2021-10-25T17:40:56Z",
      "mergedAt": "2021-10-25T17:40:55Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "97d66995edc9ce0109326ad22645e691eabef0f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4u8HVr",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T13:07:49Z",
          "updatedAt": "2021-10-24T13:07:50Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "This is just a reflow.",
              "createdAt": "2021-10-24T13:07:50Z",
              "updatedAt": "2021-10-24T13:07:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u8OxM",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-24T18:33:58Z",
          "updatedAt": "2021-10-24T18:39:56Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "bounds?  Maybe guidance?  There aren't any MUSTs below.",
              "createdAt": "2021-10-24T18:33:58Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\n{{QUIC-RECOVERY}}, rely on receipt of acknowledgments to send additional data into\r\n```",
              "createdAt": "2021-10-24T18:34:35Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            },
            {
              "originalPosition": 64,
              "body": "nit: This is only when there are bytes in flight.  It's not once per RTT regardless of what's being sent.",
              "createdAt": "2021-10-24T18:35:19Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            },
            {
              "originalPosition": 74,
              "body": "Increase from every 2 packets?",
              "createdAt": "2021-10-24T18:36:16Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            },
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nReceiving an acknowledgement an allow a sender to release new packets into\r\n```",
              "createdAt": "2021-10-24T18:36:39Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            },
            {
              "originalPosition": 81,
              "body": "I'm not sure we need a new MUST here, can we just cite the existing MUST in recovery?\r\n```suggestion\r\nbursts of data into the network. A sender needs limit such bursts to the initial congestion window at most In keeping\r\n```",
              "createdAt": "2021-10-24T18:38:06Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            },
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nAcknowledgements are fundamental to reliability in QUIC. Consequently,\r\n```",
              "createdAt": "2021-10-24T18:38:19Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            },
            {
              "originalPosition": 104,
              "body": "You say this above on line 412",
              "createdAt": "2021-10-24T18:39:25Z",
              "updatedAt": "2021-10-24T18:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u9qsN",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T10:10:19Z",
          "updatedAt": "2021-10-25T10:10:20Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Bounds implies numbers to me, or hard constraints. This is at least guidance.",
              "createdAt": "2021-10-25T10:10:20Z",
              "updatedAt": "2021-10-25T10:10:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u9r3O",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T10:15:08Z",
          "updatedAt": "2021-10-25T10:15:08Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "I'd prefer not to be imply a starting position of 1 ACK to 2 Packets. \r\nI'd like to say *why* to provide robustness to loss of an ACK; to enable more accurate tracking of RTT; or whatever.\r\n\r\nPerhaps for me, it would be nice as an example; \"For example, to send an ACK every packet to increase the robustness to loss of an ACK; to enable more accurate tracking of RTT\" ?",
              "createdAt": "2021-10-25T10:15:08Z",
              "updatedAt": "2021-10-25T10:15:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u9r-n",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T10:15:35Z",
          "updatedAt": "2021-10-25T10:15:35Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "allows a sender?",
              "createdAt": "2021-10-25T10:15:35Z",
              "updatedAt": "2021-10-25T10:15:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u9sH3",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T10:16:09Z",
          "updatedAt": "2021-10-25T10:16:09Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "needs to limit ... with a citation of which section in RFC9000?",
              "createdAt": "2021-10-25T10:16:09Z",
              "updatedAt": "2021-10-25T10:16:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u9t6a",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T10:23:37Z",
          "updatedAt": "2021-10-25T10:23:37Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I don't agree with this text ((If this were EXP then I'd set different expecatations)). My take is that \"Implementers can select an appropriate strategy to meet the needs of their applications and congestion controllers\". The difference is that I don't think a PS should encourage experimentation on the Internet without defining what is safe ... I'd still hope the experiments take place and innovation occurs, and then expect if this differs to what is said here then proposed changes are reported in ICCRG (for example), and after (maybe) the advice in the PS can be updated.",
              "createdAt": "2021-10-25T10:23:37Z",
              "updatedAt": "2021-10-25T10:23:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u95kY",
          "commit": {
            "abbreviatedOid": "17aa863"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Feedback incorporated",
          "createdAt": "2021-10-25T11:15:12Z",
          "updatedAt": "2021-10-25T11:29:09Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "changed to guidance",
              "createdAt": "2021-10-25T11:15:12Z",
              "updatedAt": "2021-10-25T11:29:09Z"
            },
            {
              "originalPosition": 74,
              "body": "I've used @gorryfair 's suggestion.",
              "createdAt": "2021-10-25T11:20:40Z",
              "updatedAt": "2021-10-25T11:29:09Z"
            },
            {
              "originalPosition": 78,
              "body": "using `can allow`",
              "createdAt": "2021-10-25T11:21:42Z",
              "updatedAt": "2021-10-25T11:29:10Z"
            },
            {
              "originalPosition": 81,
              "body": "I think this normative is useful here, since these bursts are more than what 9002 can cause... even if the normative in 9002 changes, this applies independently. At the moment, we are using suggestions from there, but the normative is useful.",
              "createdAt": "2021-10-25T11:24:40Z",
              "updatedAt": "2021-10-25T11:29:10Z"
            },
            {
              "originalPosition": 104,
              "body": "Although the recommendations are the same, these are two recommendations for two different reasons. I tried to structure it so it wouldn't repeat, but it just seemed easier and cleaner to repeat the same recommendation twice. Each section here now has a recommendation.",
              "createdAt": "2021-10-25T11:26:47Z",
              "updatedAt": "2021-10-25T11:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u99Bw",
          "commit": {
            "abbreviatedOid": "c68e715"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T11:31:08Z",
          "updatedAt": "2021-10-25T11:31:08Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Fair point -- changed to `can` and flipped the order of the sentences.",
              "createdAt": "2021-10-25T11:31:08Z",
              "updatedAt": "2021-10-25T11:31:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u99cr",
          "commit": {
            "abbreviatedOid": "4458a28"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T11:33:02Z",
          "updatedAt": "2021-10-25T11:33:03Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Sorry, took your better sentence and flipped the order.",
              "createdAt": "2021-10-25T11:33:03Z",
              "updatedAt": "2021-10-25T11:33:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u_diR",
          "commit": {
            "abbreviatedOid": "4458a28"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T17:00:19Z",
          "updatedAt": "2021-10-25T17:00:20Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\ninto the network. A sender neeeds to limit such bursts as specified in Section 7.7\r\nof {{QUIC-RECOVERY}}.  A sender can either employ pacing or cause a receiver to\r\n```",
              "createdAt": "2021-10-25T17:00:19Z",
              "updatedAt": "2021-10-25T17:00:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u_fHQ",
          "commit": {
            "abbreviatedOid": "4458a28"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T17:06:52Z",
          "updatedAt": "2021-10-25T17:06:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "PR_kwDODddxTs4tl5Xi",
      "title": "Rework IMMEDIATE_ACK section a bit",
      "url": "https://github.com/quicwg/ack-frequency/pull/102",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also,\r\nCloses #70.",
      "createdAt": "2021-10-24T16:55:52Z",
      "updatedAt": "2021-10-25T17:37:46Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "3c31c3043afc5172bc0bd39e89e2d7c2c6017af0",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/immediate",
      "headRefOid": "3debcae98b758df606e5c2be3a1b19af79ffc695",
      "closedAt": "2021-10-25T17:37:45Z",
      "mergedAt": "2021-10-25T17:37:45Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "6117149d0d40634b1207a02afb8992d1e2b3ef0f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4u8N53",
          "commit": {
            "abbreviatedOid": "c6f3dd0"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T17:52:48Z",
          "updatedAt": "2021-10-24T17:52:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u8Vc7",
          "commit": {
            "abbreviatedOid": "c6f3dd0"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-24T23:46:46Z",
          "updatedAt": "2021-10-24T23:46:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODddxTs4u9xUN",
          "commit": {
            "abbreviatedOid": "c6f3dd0"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Seems would benefit from a little polish and some improvement in the examples.",
          "createdAt": "2021-10-25T10:38:14Z",
          "updatedAt": "2021-10-25T10:46:03Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I think there could be more examples: I'd thought one specific use for this was to make an immediate RTT measurement. \r\n\r\n(Side comment: There could even be some cases where a sender might learn more... I'd also speculated there could be useful info gleaned  from taking several RTT samples in direct succession, whether or not that indeed proves useful is something I have yet to learn.)",
              "createdAt": "2021-10-25T10:38:15Z",
              "updatedAt": "2021-10-25T10:46:03Z"
            },
            {
              "originalPosition": 36,
              "body": "/vast majority/majority/  ? (is majority even the correct word... I'd expect that this really should not be set for even half the packets!)",
              "createdAt": "2021-10-25T10:40:23Z",
              "updatedAt": "2021-10-25T10:46:03Z"
            },
            {
              "originalPosition": 22,
              "body": "/hurt/ reduce... or something?",
              "createdAt": "2021-10-25T10:41:18Z",
              "updatedAt": "2021-10-25T10:46:03Z"
            },
            {
              "originalPosition": 23,
              "body": "I fear this suggests \"immediate\" *IS* always useful, and that doesn't seem true. When we look at this sort of mechanism with SCTP, it actually was not normally useful. However, there were corner-cases when this did add benefit - and I think these were mostly focussed on the end of a tail in transmission when the sender knew there would not be a pause in transmission or no more packets following a previous (set of)  packets. ",
              "createdAt": "2021-10-25T10:45:37Z",
              "updatedAt": "2021-10-25T10:46:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u-AIt",
          "commit": {
            "abbreviatedOid": "c6f3dd0"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T11:44:46Z",
          "updatedAt": "2021-10-25T11:44:47Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I've added the immediate RTT example and also a quick liveness check example. On your second comment -- this frame is different than SCTP, since the context is different. In the case of this draft, a sender deliberately delays acks for longer, and the IMMEDIATE_ACK is primarily an escape hatch when that increased delay hurts.",
              "createdAt": "2021-10-25T11:44:46Z",
              "updatedAt": "2021-10-25T11:44:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4u-AVV",
          "commit": {
            "abbreviatedOid": "c6f3dd0"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T11:45:31Z",
          "updatedAt": "2021-10-25T11:45:31Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "changed to `large number`",
              "createdAt": "2021-10-25T11:45:31Z",
              "updatedAt": "2021-10-25T11:45:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 108,
      "id": "PR_kwDODddxTs4uGpjV",
      "title": "Remove simply",
      "url": "https://github.com/quicwg/ack-frequency/pull/108",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fixes #105",
      "createdAt": "2021-11-04T16:38:42Z",
      "updatedAt": "2021-11-04T17:47:53Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "97d66995edc9ce0109326ad22645e691eabef0f3",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-simply",
      "headRefOid": "74ceabd5c33280f9d5fc3b66ff291e8a21c62c4f",
      "closedAt": "2021-11-04T17:47:53Z",
      "mergedAt": "2021-11-04T17:47:52Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "6508bb9ea950acc92295d9333ac178ec1c0f5874"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODddxTs4vkVD0",
          "commit": {
            "abbreviatedOid": "74ceabd"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-04T17:27:14Z",
          "updatedAt": "2021-11-04T17:27:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDODddxTs4uWch5",
      "title": "Remove confusing links",
      "url": "https://github.com/quicwg/ack-frequency/pull/112",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-10T14:09:47Z",
      "updatedAt": "2021-11-10T15:05:15Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "6508bb9ea950acc92295d9333ac178ec1c0f5874",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-confusing-links",
      "headRefOid": "692f994d662381d50f188063c5e06f9d40742d5d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I think removing the link to https://github.com/quicwg/ack-frequency/blob/main/draft-ietf-quic-ack-frequency.md actually have some down sides as it contains non MD that are easier to read. However, that page is out of date. Which I think can be fixed by running make gh-pages? ",
          "createdAt": "2021-11-10T15:05:15Z",
          "updatedAt": "2021-11-10T15:05:15Z"
        }
      ],
      "reviews": []
    }
  ]
}